{
	"main": {
		"prefix": "main",
		"body": [
			"#include <bits/stdc++.h>",
			"#define rep(i, a, b) for (ll i = a; i < b; i++)",
			"#define rrep(i, a, b) for (ll i = a; i >= b; i--)",
			"#define fore(i, a) for (auto &i : a)",
			"#define all(x) (x).begin(), (x).end()",
			"#define YES cout << \"Yes\" << endl",
			"#define NO cout << \"No\" << endl",
			"#define YN { cout << \"Yes\" << endl; } else { cout << \"No\" << endl; } // if(a==b)YN;",
			"#define FAIL cout << -1 << endl",
			"#pragma GCC optimize(\"-O3\")",
			"",
			"using namespace std;",
			"using ll = long long;",
			"using ld = long double;",
			"using i128 = __int128_t;",
			"using pll = pair<ll, ll>;",
			"using pld = pair<ld, ld>;",
			"using matrix = vector<vector<ll>>;",
			"using matrixld = vector<vector<ld>>;",
			"using matrixb = vector<vector<bool>>;",
			"using onevec = vector<ll>;",
			"using onevecld = vector<ld>;",
			"using onevecb = vector<bool>;",
			"using lset = set<ll>;",
			"",
			"const ll INFL = 1LL << 60;",
			"template <class T> T chmin(T &a, T b) {",
			"  if (a > b) {",
			"    a = b;",
			"  }",
			"  return a;",
			"}",
			"template <class T> T chmax(T &a, T b) {",
			"  if (a < b) {",
			"    a = b;",
			"  }",
			"  return a;",
			"}",
			"template <typename T> ll lsize(const T &container) {",
			"  return static_cast<ll>(container.size());",
			"}",
			"template <typename T> bool ifbit(T number, ll bit) {",
			"  return (number & (1LL << bit)) != 0;",
			"}",
			"template <typename T> ll twice(const T &a) { return a * a; }",
			"template <typename T> T bits_count(T v) { return __builtin_popcountll(v); }",
			"",
			"template <typename T> T factorial(T n) {",
			"  T result = 1;",
			"  for (T i = 1; i <= n; ++i) {",
			"    result *= i;",
			"  }",
			"  return result;",
			"}",
			"",
			"template <typename T> T pdistance(const vector<pair<T, T>> &xy, int i, int j) {",
			"  return sqrt(twice(xy[i].first - xy[j].first) +",
			"              twice(xy[i].second - xy[j].second));",
			"}",
			"template <typename T>",
			"int isperp(const vector<pair<T, T>> &xyz, int i, int j, int k) {",
			"    T dx1 = xyz[i].first - xyz[j].first, dy1 = xyz[i].second - xyz[j].second;",
			"    T dx2 = xyz[k].first - xyz[j].first, dy2 = xyz[k].second - xyz[j].second;",
			"",
			"    T dot = dx1 * dx2 + dy1 * dy2;",
			"",
			"    return (dot > 0) ? 0 : (dot == 0) ? 1 : -1;",
			"}",
			"",
			"template <typename T>",
			"T crossp(const vector<pair<T, T>> &xyz, int i, int j, int k) {",
			"    T dx1 = xyz[i].first - xyz[j].first, dy1 = xyz[i].second - xyz[j].second;",
			"    T dx2 = xyz[k].first - xyz[j].first, dy2 = xyz[k].second - xyz[j].second;",
			"",
			"    return dx1 * dy2 - dy1 * dx2;",
			"}",
			"",
			"template <typename T>",
			"T mod_exp(T base, T exp, T mod) {",
			"    T result = 1;",
			"    while (exp > 0) {",
			"        if (exp & 1) result = (result * base) % mod;",
			"        base = (base * base) % mod;",
			"        exp >>= 1;",
			"    }",
			"    return result;",
			"}",
			"",
			"template <typename T> void print(T value, int precision) {",
			"  cout << fixed << setprecision(precision) << value << endl;",
			"}",
			"",
			"template <typename... Args> void in(Args &...args) { (cin >> ... >> args); }",
			"",
			"template <typename... Args> void out(const Args &...args) {",
			"  constexpr size_t n = sizeof...(args);",
			"  size_t i = 0;",
			"  ((cout << args << (++i < n ? \" \" : \"\")), ...) << \"\\n\";",
			"}",
			"",
			"const int dx[8] = {1, 0, -1, 0, 1, 1, -1, -1};",
			"const int dy[8] = {0, 1, 0, -1, 1, -1, 1, -1};",
			"string strrep(const string &s, const string &from, const string &to) {",
			"",
			"    unordered_map<char, char> trans;",
			"    for (size_t i = 0; i < from.size(); ++i) {",
			"        trans[from[i]] = to[i];",
			"    }",
			"",
			"    string res = s;",
			"    for (char &c : res) {",
			"        if (trans.count(c)) {",
			"            c = trans[c];",
			"        }",
			"    }",
			"    return res;",
			"}",
			"template <typename T> bool isprime(T N) {",
			" if (N < 2)",
			"  return false;",
			" for (T i = 2; i * i <= N; i++) {",
			" if (N % i == 0)",
			"   return false;",
			" }",
			" return true;",
			"}",
			"vector<pair<char, int>> rle(const string &s) {",
			"    vector<pair<char, int>> res;",
			"    for (int i = 0, cnt; i < s.size(); i += cnt) {",
			"        cnt = 1;",
			"        while (i + cnt < s.size() && s[i] == s[i + cnt])",
			"            cnt++;",
			"        res.emplace_back(s[i], cnt);",
			"    }",
			"    return res;",
			"}",
			"/*--------------------------------------------------------",
			"                         \\0w0/ ",
			"                        OwOkaomoji",
			"                     ｡˚ (¦3ꇤ )3 ⋆｡˚✩",
			"----------------------------------------------------------*/",
			"",
			"int main() {",
			"    ios::sync_with_stdio(false);",
			"    cin.tie(nullptr);",
			"    $1",
			"    ll n;",
			"    in(n);",
			"    return 0;",
			"}",
		]
	},
	"bfs": {
		"prefix": "bfs",
		"body": [
			"void bfs(const matrix& G, ll start, vector<ll>& dist) {",
			"    ll n = G.size();",
			"    queue<ll> que;",
			"",
			"    dist[start] = 0; // 初期ノード",
			"    que.push(start);",
			"",
			"    while (!que.empty()) {",
			"        ll v = que.front();",
			"        que.pop();",
			"",
			"        for (ll nv : G[v]) {",
			"            if (dist[nv] != -1) continue; // 訪問済み",
			"            dist[nv] = dist[v] + 1;",
			"            que.push(nv);",
			"        }",
			"    }",
			"}",
			"",
			"int main() {",
			"    $1",
			"    ll N, M; // 頂点数と辺数",
			"    cin >> N >> M;",
			"",
			"    matrix G(N); ",
			"    for (ll i = 0; i < M; ++i) { // 辺の入力",
			"        ll u, v;",
			"        cin >> u >> v;",
			"        u--; v--; // 0-indexedに変換",
			"        G[u].push_back(v);",
			"        G[v].push_back(u); // 無向グラフ",
			"    }",
			"",
			"    vector<ll> dist(N, -1); // 距離配列",
			"    bfs(G, 0, dist); // 頂点0を始点としてBFS実行",
			"",
			"    for (ll v = 0; v < N; ++v) {",
			"        cout << dist[v] << \"\\n\";",
			"    }",
			"",
			"    return 0;",
			"}"
		],
	},
	"01bfs": {
		"prefix": "01bfs",
		"body": [
			"// グラフは (次の頂点, 重み) のペアリストとして表現",
			"typedef vector<vector<pair<ll, ll>>> Graph;",
			"",
			"void bfs(const Graph &G, ll start, vector<ll> &dist) {",
			"    int n = G.size();",
			"    dist.assign(n, INFL);",
			"    deque<ll> dq;",
			"    dist[start] = 0;",
			"    dq.push_back(start);",
			"",
			"    while (!dq.empty()) {",
			"        ll v = dq.front();",
			"        dq.pop_front();",
			"        for (auto &edge : G[v]) {",
			"            ll nv = edge.first, w = edge.second;",
			"            if (dist[nv] > dist[v] + w) {",
			"                dist[nv] = dist[v] + w;",
			"                if (w == 0)",
			"                    dq.push_front(nv);",
			"                else",
			"                    dq.push_back(nv);",
			"            }",
			"        }",
			"    }",
			"}",
			"",
			"int main() {",
			"    ios::sync_with_stdio(false);",
			"    cin.tie(nullptr);",
			"",
			"    ll N;",
			"    cin >> N;",
			"    vector<string> S(N);",
			"    for (ll i = 0; i < N; i++) {",
			"         cin >> S[i];",
			"    }",
			"",
			"    ll total = N * N;",
			"    Graph G(total + 1);",
			"",
			"    for (ll i = 0; i < N; i++){",
			"         ll idx = i * N + i;",
			"         G[total].push_back({idx, 0});",
			"    }",
			"",
			"    for (ll i = 0; i < N; i++){",
			"         for (ll j = 0; j < N; j++){",
			"              if (i == j) continue;",
			"              if (S[i][j] != '-') {",
			"                   ll idx = i * N + j;",
			"                   G[total].push_back({idx, 1});",
			"              }",
			"         }",
			"    }",
			"",
			"    for (ll i = 0; i < N; i++){",
			"         for (ll j = 0; j < N; j++){",
			"              ll cur = i * N + j;",
			"              for (ll k = 0; k < N; k++){",
			"                  for (ll l = 0; l < N; l++){",
			"                      if (S[k][i] != '-' && S[j][l] != '-' && S[k][i] == S[j][l]) {",
			"                          ll nxt = k * N + l;",
			"                          G[cur].push_back({nxt, 2});",
			"                      }",
			"                  }",
			"              }",
			"         }",
			"    }",
			"",
			"    vector<ll> dist;",
			"    bfs(G, total, dist);",
			"",
			"    for (ll i = 0; i < N; i++){",
			"         for (ll j = 0; j < N; j++){",
			"              ll idx = i * N + j;",
			"              cout << (dist[idx] == INFL ? -1 : dist[idx]) << \" \";",
			"         }",
			"         cout << \"\\n\";",
			"    }",
			"",
			"    return 0;",
			"}"
		],
	},
	"bin": {
		"prefix": "bin",
		"body": [
			"ll my_bin(ll ok, ll ng, function<bool(ll)> condition) {",
			"    while (abs(ok - ng) > 1) {",
			"        ll mid = (ok + ng) / 2;",
			"        if (condition(mid)) {",
			"            ok = mid;",
			"        } else {",
			"            ng = mid;",
			"        }",
			"    }",
			"    return ok;",
			"}",
			"",
			"int main() {",
			"    $1",
			"    ll n, q;",
			"    cin >> n >> q;",
			"",
			"    vector<ll> A(n);",
			"    fore(a,A) cin >> a;",
			"    sort(all(A));",
			"",
			"    rep(i,0,q) {",
			"        ll x;",
			"        cin >> x;",
			"",
			"        auto condition = [&](ll mid) { return A[mid] >= x; };",
			"",
			"        ll idx = my_bin(llsize(A), -1, condition);",
			"        cout << n - idx << endl;",
			"    }",
			"",
			"    return 0;",
			"}"
		],
	},
	"divisors": {
		"prefix": "divisors",
		"body": [
			"vector<ll> calc_divisors(ll N) {",
			" vector<ll> res;",
			"",
			" for (ll i = 1; i * i <= N; ++i) {",
			"  if (N % i != 0) continue;",
			"",
			"  res.push_back(i);",
			"",
			"  if (N / i != i) res.push_back(N / i);",
			" }",
			"",
			" sort(res.begin(), res.end());",
			" return res;",
			"}",
			"    $1",
		]
	},
	"prime_fac": {
		"prefix": "prime_fac",
		"body": [
			"vector<pair<ll, ll>> prime_factorize(ll N) {",
			"    vector<pair<ll, ll>> res;",
			"",
			"    for (ll p = 2; p * p <= N; ++p) {",
			"        if (N % p != 0) {",
			"            continue;",
			"        }",
			"",
			"        ll e = 0;",
			"        while (N % p == 0) {",
			"            ++e;",
			"            N /= p;",
			"        }",
			"",
			"        res.emplace_back(p, e);",
			"    }",
			"",
			"    if (N != 1) {",
			"        res.emplace_back(N, 1);",
			"    }",
			"    return res;",
			"}",
			"",
			"int main() {",
			"    $1",
			"    ll n;",
			"    cin >> n;",
			"    const auto &pf = prime_factorize(n);",
			"    for (const auto &p : pf) {",
			"        cout << p.first << \" \" << p.second << endl;",
			"    }",
			"    return 0;",
			"}"
		]
	},
	"dp": {
		"prefix": "dp",
		"body": [
			"int main() {",
			"    $1",
			" ll n;",
			" cin >> n;",
			"",
			" vector<ll> h(n); ",
			" for (ll i = 0; i < n; ++i) {",
			"  cin >> h[i];",
			" }",
			" vector<ll> dp(n, INFL);",
			"",
			" // 初期条件の設定",
			" dp[0] = 0;",
			"",
			" // ループ",
			" for (ll i = 1; i < n; ++i) {",
			"  chmin(dp[i], dp[i - 1] + abs(h[i] - h[i - 1]));",
			" }",
			"",
			" // 結果の出力",
			" cout << dp[n - 1] << endl;",
			"",
			" return 0;",
			"}",
		]
	},
	"findstr": {
		"prefix": "findstr",
		"body": [
			"struct findstr {",
			"    string S;",
			"    ll N;",
			"    findstr() {}",
			"    findstr(string s) { init(s); }",
			"    void init(string s) {",
			"        S = s;",
			"        N = S.length();",
			"        init();",
			"    }",
			"    // get the nearest index for the char",
			"    vector<ll> left[26], right[26];",
			"    inline void init() {",
			"        rep(c, 0, 25) {",
			"            right[c].resize(N);",
			"            right[c][N - 1] = INFI;",
			"        }",
			"        rrep(i, N - 2, 0) {",
			"            rep(c, 0, 25) right[c][i] = right[c][i + 1];",
			"            right[S[i + 1]][i] = i + 1;",
			"        }",
			"        rep(c, 0, 25) {",
			"            left[c].resize(N);",
			"            left[c][0] = -1;",
			"        }",
			"        rep(i, 1, N - 1) {",
			"            rep(c, 0, 25) left[c][i] = left[c][i - 1];",
			"            left[S[i - 1]][i] = i - 1;",
			"        }",
			"    }",
			"    inline ll goright(ll cu, ll c) {",
			"        if (cu == INFI) return INFI;",
			"        if (cu < 0) {",
			"            if (S[0] == c) return 0;",
			"            cu = 0;",
			"        }",
			"        return right[c][cu];",
			"    }",
			"    inline ll goleft(ll cu, ll c) {",
			"        if (cu < 0) return cu;",
			"        return left[c][cu];",
			"    }",
			"};",
			"",
			"int main() {",
			"    $1",
			"    ll N;",
			"    string S;",
			"    cin >> N >> S;",
			"",
			"    fore(c, S) c -= '0';",
			"    findstr sm(S);",
			"",
			"    ll ans = 0;",
			"    rep(x0, 0, 9) rep(x1, 0, 9) rep(x2, 0, 9) {",
			"        ll cu = -1;",
			"        cu = sm.goright(cu, x0);",
			"        cu = sm.goright(cu, x1);",
			"        cu = sm.goright(cu, x2);",
			"        if (cu < INFI) ans++;",
			"    }",
			"    cout << ans << endl;",
			"}"
		]
	},
	"findpll": {
		"prefix": "findpll",
		"body": [
			"int main() {",
			"    $1",
			"    const ll max_this = 1000000;",
			"    ll n;",
			"    cin >> n;",
			"",
			"    vector<ll> x_n(n);",
			"    vector<ll> y_n(n);",
			"    set<pll> isin; ",
			"",
			"    for (ll i = 0; i < n; ++i) {",
			"        cin >> x_n[i] >> y_n[i];",
			"        isin.insert(make_pair(x_n[i], y_n[i])); // 座標をセットに挿入",
			"    }",
			"    // 座標が含まれるかをチェックするラムダ関数",
			"    auto check = [&](ll x, ll y) -> bool {",
			"        if (x < 0 || x > max_this || y < 0 || y > max_this) {",
			"            return false; // 範囲外",
			"        }",
			"        return isin.count(make_pair(x, y)) > 0; ",
			"    };",
			"",
			"    // 座標を入力してチェック",
			"    ll a, b;",
			"    cin >> a >> b;",
			"    if (check(a, b)) {",
			"        cout << \"Yes\" << endl;",
			"    } else {",
			"        cout << \"No\" << endl;",
			"    }",
			"",
			"    return 0;",
			"}"
		]
	},
	"tri": {
		"prefix": "tri",
		"body": [
			"ld my_tri(ld ok, ld ng, function<ld(ld)> f) {",
			" while (abs(ok - ng) > 1e-11) {",
			"   ld mid_l = (ok + ng * 2) / 3;",
			"   ld mid_r = (ok * 2 + ng) / 3;",
			"   if (f(mid_l) > f(mid_r)) {",
			"     ng = mid_l;",
			"   } else {",
			"     ok = mid_r;",
			"   }",
			" }",
			" return ok;",
			"}",
			"",
			"int main() {",
			"    $1",
			" ld p;",
			" cin >> p;",
			"",
			" auto f = [&](ld mid) {",
			"   return mid + p / pow(2, mid / 1.5);",
			" };",
			"",
			" ld idx = my_tri(INFL, 0, f);",
			" print(f(idx), 10);",
			" return 0;",
			"}",
		]
	},
	"dfs_one": {
		"prefix": "dfs_one",
		"body": [
			"class DFS {",
			"public:",
			"vector<bool> seen;",
			"vector<ll> f_o, l_o;",
			"ll ptr;",
			"ll cnt;",
			"",
			"DFS(const matrix &G) : seen(G.size(), false), f_o(G.size(), 0), l_o(G.size(), 0), ptr(0), cnt(0) {",
			"for (ll i = 0; i < (ll)G.size(); i++) {",
			"if (!seen[i]) {",
			"cnt++;",
			"dfs(G, i);",
			"}",
			"}",
			"}",
			"",
			"void dfs(const matrix &G, ll v) {",
			"seen[v] = true;",
			"f_o[v] = ++ptr;",
			"for (ll n_v : G[v]) {",
			"if (!seen[n_v]) dfs(G, n_v);",
			"}",
			"l_o[v] = ++ptr;",
			"}",
			"",
			"void output() const {",
			"for (ll i = 0; i < (ll)f_o.size(); i++) {",
			"printf(\"%lld %lld %lld\\n\", i + 1, f_o[i], l_o[i]);",
			"}",
			"printf(\"%lld\\n\", cnt);",
			"}",
			"};",
			"",
			"int main() {",
			"ll n;",
			"cin >> n;",
			"matrix G(n);",
			"for (ll i = 0; i < n; i++) {",
			"ll u, k;",
			"cin >> u >> k;",
			"u--;",
			"for (ll j = 0; j < k; j++) {",
			"ll v;",
			"cin >> v;",
			"v--;",
			"G[u].push_back(v);",
			"}",
			"}",
			"DFS dfs_solver(G);",
			"dfs_solver.output();",
			"return 0;",
			"}"
		]
	},
	"dfs_matrix": {
		"prefix": "dfs_matrix",
		"body": [
			"// DFSクラス：グリッド上で深さ優先探索を行い、連結成分の個数を数える",
			"class DFS {",
			"public:",
			"  // 各セルが既に訪問済みかどうかを記録する2次元配列",
			"  vector<vector<bool>> seen;",
			"  // 各セルの「発見時刻」を記録する2次元配列",
			"  vector<vector<ll>> f_o;",
			"  // 各セルの「終了時刻」を記録する2次元配列",
			"  vector<vector<ll>> l_o;",
			"  // DFSのタイムスタンプを管理する変数",
			"  ll ptr;",
			"  // 連結成分（グループ）の数を記録する変数",
			"  ll cnt;",
			"",
			"  // コンストラクタ：グリッドGを受け取り、DFS探索を実行する",
			"  DFS(const matrix &G)",
			"      : seen(G.size(), vector<bool>(G[0].size(), false)),",
			"        f_o(G.size(), vector<ll>(G[0].size(), 0)),",
			"        l_o(G.size(), vector<ll>(G[0].size(), 0)),",
			"        ptr(0), cnt(0) {",
			"",
			"    // グリッド内の全てのセルについてループ",
			"    for (ll i = 0; i < (ll)G.size(); i++) {",
			"      rep(j, 0, G[0].size()) {",
			"        // 未訪問かつセルの値が1の場合（つまり探索対象のセルの場合）",
			"        if (!seen[i][j] && G[i][j] == 1) {",
			"          cnt++;",
			"          dfs(G, i, j);",
			"        }",
			"      }",
			"    }",
			"  }",
			"",
			"  // DFSの再帰関数：セル(h, w)から始めて、連結する全セルを探索する",
			"  void dfs(const matrix &G, ll h, ll w) {",
			"    seen[h][w] = true;",
			"    f_o[h][w] = ++ptr;",
			"",
			"    // 8方向（上下左右斜めを含む）の隣接セルを調べる",
			"    rep(i, 0, 8) {",
			"      ll nh = h + dx[i];",
			"      ll nw = w + dy[i];",
			"",
			"      // 隣接セルがグリッドの範囲内にあるかをチェック",
			"      if (nh >= 0 && nh < (ll)G.size() && nw >= 0 && nw < (ll)G[0].size()) {",
			"        // 隣接セルが未訪問かつ値が1の場合",
			"        if (!seen[nh][nw] && G[nh][nw] == 1) {",
			"          dfs(G, nh, nw);",
			"        }",
			"      }",
			"    }",
			"    l_o[h][w] = ++ptr;",
			"  }",
			"",
			"  // 連結成分の個数（cnt）を出力する関数",
			"  void output() const {",
			"    cout << cnt << endl;",
			"  }",
			"};",
			"",
			"int main() {",
			"  ll W, H;",
			"  cin >> W >> H;",
			"  // (W, H)が両方0になるまでループする",
			"  while (!(!W && !H)) {",
			"    matrix G(H);",
			"",
			"    // グリッドの各セルに値を読み込む",
			"    rep(i, 0, H) rep(j, 0, W) {",
			"      ll v;",
			"      cin >> v;",
			"      G[i].push_back(v);",
			"    }",
			"",
			"    // DFSクラスを用いてグリッド上の連結成分（値が1の部分）を探索する",
			"    DFS dfs_solver(G);",
			"    // 連結成分の数を出力する",
			"    dfs_solver.output();",
			"",
			"    // 次のグリッドのサイズを入力",
			"    cin >> W >> H;",
			"  }",
			"  return 0;",
			"}"
		]
	},
	"dfs_depth": {
		"prefix": "dfs_depth",
		"body": [
			"class DFS {",
			"    public:",
			"        vector<vector<bool>> seen; // 訪問済みを記録する2D配列",
			"        ll max_depth; // 最大探索深さ",
			"",
			"        // コンストラクタ: 与えられたグリッドGを探索",
			"        DFS(const matrix &G)",
			"                : seen(G.size(), vector<bool>(G[0].size(), false)), max_depth(0) {",
			"            for (ll i = 0; i < (ll)G.size(); i++) {",
			"                for (ll j = 0; j < (ll)G[0].size(); j++) {",
			"                    if (G[i][j] == 1) { // 1があるセルから探索開始",
			"                        dfs(G, i, j, 1);",
			"                    }",
			"                }",
			"            }",
			"        }",
			"",
			"        // 深さ優先探索 (DFS)",
			"        void dfs(const matrix &G, ll h, ll w, ll d) {",
			"            seen[h][w] = true; // 現在のセルを訪問済みにする",
			"            chmax(max_depth, d); // 最大深さを更新",
			"",
			"            // 4方向 (上下左右) に探索を進める",
			"            rep(i, 0, 4) {",
			"                ll nh = h + dx[i];",
			"                ll nw = w + dy[i];",
			"                if (nh >= 0 && nh < (ll)G.size() && nw >= 0 && nw < (ll)G[0].size()) {",
			"                    if (!seen[nh][nw] && G[nh][nw] == 1) {",
			"                        dfs(G, nh, nw, d + 1); // 深さを1増やして再帰",
			"                    }",
			"                }",
			"            }",
			"            seen[h][w] = false; // 戻るときに未訪問状態に戻す (別ルート探索用)",
			"        }",
			"",
			"        // 最大深さを出力",
			"        void output() const { cout << max_depth << endl; }",
			"};",
			"",
			"int main() {",
			"    ll W, H;",
			"    cin >> W >> H;",
			"    matrix G(H, vector<ll>(W));",
			"",
			"    // グリッドの入力",
			"    rep(i, 0, H) rep(j, 0, W) { cin >> G[i][j]; }",
			"",
			"    // DFS実行",
			"    DFS dfs_solver(G);",
			"    dfs_solver.output();",
			"",
			"    return 0;",
			"}"
		]
	},
	"dfs_matrix_tree": {
		"prefix": "dfs_matrix_tree",
		"body": [
			"class DFS {",
			"    public:",
			"        vector<vector<bool>> seen;",
			"        ll max_depth;",
			"",
			"        DFS(const matrix &G)",
			"                : seen(G.size(), vector<bool>(G[0].size(), false)), max_depth(0) {",
			"            for (ll i = 0; i < (ll)G.size(); i++) {",
			"                for (ll j = 0; j < (ll)G[0].size(); j++) {",
			"                    if (G[i][j] == 1) {",
			"                        dfs(G, i, j, 1);",
			"                    }",
			"                }",
			"            }",
			"        }",
			"",
			"        void dfs(const matrix &G, ll h, ll w, ll d) {",
			"            seen[h][w] = true;",
			"            chmax(max_depth, d);",
			"",
			"            rep(i, 0, 4) {",
			"                ll nh = h + dx[i];",
			"                ll nw = w + dy[i];",
			"                if (nh >= 0 && nh < (ll)G.size() && nw >= 0 && nw < (ll)G[0].size()) {",
			"                    if (!seen[nh][nw] && G[nh][nw] == 1) {",
			"                        dfs(G, nh, nw, d + 1);",
			"                    }",
			"                }",
			"            }",
			"            seen[h][w] = false;",
			"        }",
			"",
			"        void output() const { cout << max_depth << endl; }",
			"};",
			"",
			"int main() {",
			"    ll W, H;",
			"    cin >> W >> H;",
			"    matrix G(H, vector<ll>(W));",
			"    rep(i, 0, H) rep(j, 0, W) { cin >> G[i][j]; }",
			"    DFS dfs_solver(G);",
			"    dfs_solver.output();",
			"    return 0;",
			"}"
		]
	},
	"bfs_matrix": {
		"prefix": "bfs_matrix",
		"body": [
			"void bfs_matrix(const vector<string> &field, ll sx, ll sy, matrix &dist) {",
			"    ll height = field.size();",
			"    ll width = field[0].size();",
			"",
			"    // 探索中に各マスはどのマスから来たのかを表す配列",
			"    // (最短経路長を知るだけなら、これは不要)",
			"    vector<vector<ll>> prev_x(field.size(), vector<ll>(field[0].size(), -1));",
			"    vector<vector<ll>> prev_y(field.size(), vector<ll>(field[0].size(), -1));",
			"",
			"    queue<pair<ll, ll>> que;",
			"    dist = vector<vector<ll>>(height, vector<ll>(width, -1)); // 初期化",
			"    que.push(make_pair(sx, sy));                              // スタートを push",
			"    dist[sx][sy] = 0;                                         // スタートを 0 に",
			"",
			"    /* 幅優先探索を実施 */",
			"",
			"    while (!que.empty()) {",
			"        ll x = que.front().first;",
			"        ll y = que.front().second;",
			"        que.pop(); // キューから pop を忘れずに",
			"",
			"        // 隣接頂点を探索",
			"        rep(i, 0, 4) {",
			"            ll next_x = x + dx[i];",
			"            ll next_y = y + dy[i];",
			"",
			"            if (next_x < 0 || next_x >= height || next_y < 0 || next_y >= width)",
			"                continue;",
			"            if (field[next_x][next_y] == 'X')",
			"                continue;",
			"",
			"            // まだ見ていない頂点なら push",
			"            if (dist[next_x][next_y] == -1) {",
			"                que.push(make_pair(next_x, next_y));",
			"                dist[next_x][next_y] = dist[x][y] + 1; // (next_x, next_y) の距離も更新",
			"                prev_x[next_x][next_y] = x; // どの頂点から情報が伝播して来たか、縦方向の座標をメモ",
			"                prev_y[next_x][next_y] = y; // どの頂点から情報が伝播して来たか、横方向の座標をメモ",
			"            }",
			"        }",
			"    }",
			"}",
			"int main() {",
			"",
			"    /* 入力受け取り */",
			"",
			"    /* 縦と横の長さ */",
			"    ll h, w;",
			"    in(h,w);",
			"    ll sx, sy, gx, gy;",
			"    in(sx, sy, gx, gy);",
			"    sx--; sy--; gx--; gy--;",
			"    /* 盤面 */",
			"    vector<string> field(h);",
			"    rep(i,0,h)",
			"        cin >> field[i];",
			"",
			"    /* スタート地点とゴール地点 */",
			"    // ll sx, sy, gx, gy;",
			"    // rep(i,0,h){",
			"    //   rep(j,0,w) {",
			"    //     if (field[i][j] == 'S') {",
			"    //       sx = i;",
			"    //       sy = j;",
			"    //     }",
			"    //     if (field[i][j] == 'G') {",
			"    //       gx = i;",
			"    //       gy = j;",
			"    //     }",
			"    //   }",
			"    // }",
			"",
			"    /* 幅優先探索の初期設定 */",
			"",
			"    // 各セルの最短距離 (訪れていないところは -1 としておく)",
			"    vector<vector<ll>> dist(h, vector<ll>(w, -1));",
			"    bfs_matrix(field, sx, sy, dist);",
			"",
			"    /* 結果出力 */",
			"",
			"    // ll x = gx, y = gy;",
			"    // while (x != -1 && y != -1) {",
			"    //   field[x][y] = 'o'; // 通過したことを示す",
			"",
			"    //   // 前の頂点へ行く",
			"    //   ll px = prev_x[x][y];",
			"    //   ll py = prev_y[x][y];",
			"    //   x = px, y = py;",
			"    // }",
			"    //rep (i,0,h) {",
			"    //  rep(j,0,w) {",
			"    //     cout << std::setw(3) << field[i][j];",
			"    //   }",
			"    //   cout << endl;",
			"    // }",
			"",
			"    out(dist[gx][gy]);",
			"    return 0;",
			"}",
		]
	},
	"dp_matrix": {
		"prefix": "dp_matrix",
		"body": [
			"struct DP {",
			"    ll n, m;",
			"    matrix dp;",
			"",
			"    DP(ll _n, ll _m, ll init = 0) : n(_n), m(_m) {",
			"        dp.assign(n, onevec(m, init));",
			"    }",
			"",
			"    // 状態遷移の例（最小コストを求めるパターン）",
			"    void trmin(ll i, ll j, ll cost) {",
			"        if (i > 0) chmin(dp[i][j], dp[i - 1][j] + cost);",
			"        if (j > 0) chmin(dp[i][j], dp[i][j - 1] + cost);",
			"    }",
			"",
			"    // 状態遷移の例（最大コストを求めるパターン）",
			"    void trmax(ll i, ll j, ll cost) {",
			"        if (i > 0) chmax(dp[i][j], dp[i - 1][j] + cost);",
			"        if (j > 0) chmax(dp[i][j], dp[i][j - 1] + cost);",
			"    }",
			"",
			"    // 結果の取得",
			"    ll get_result() {",
			"        return dp[n - 1][m - 1];",
			"    }",
			"",
			"    // DP テーブルのデバッグ出力",
			"    void debug() {",
			"        rep(i, 0, n) {",
			"            rep(j, 0, m) cout << (dp[i][j] == INFL ? \"INF\" : to_string(dp[i][j])) << \" \";",
			"            cout << endl;",
			"        }",
			"    }",
			"};",
			"",
			"int main() {",
			"    ll n, m;",
			"    in(n,m);",
			"    DP dp(n, m, INFL);",
			"",
			"    // 初期化",
			"    dp.dp[0][0] = 0;",
			"",
			"    // 例: グリッド DP（右・下移動のみ）",
			"    rep(i, 0, n) rep(j, 0, m) {",
			"        ll cost;",
			"        in(cost);",
			"        dp.trmin(i, j, cost);",
			"    }",
			"",
			"    out(dp.get_result());",
			"    return 0;",
			"}"
		]
	},
	"inter_dp": {
		"prefix": "inter_dp",
		"body": [
			"ll n;",
			"onevec d;",
			"matrix dp;",
			"",
			"// 区間 [l, r] の最適解を求めるDP",
			"ll rec(ll l, ll r) {",
			"\tll &target = dp[l][r];",
			"\tif (target != -1) return target;",
			"\tif (l == r) return target = 0;",
			"",
			"\t// // 例: 区間全体を一括で処理できる場合",
			"\t// if (/* 条件（例えば data[l] と data[r] を使って処理できるか） */) {",
			"\t// \treturn target = /* 適切な値 */;",
			"\t// }",
			"",
			"\t// 例: 区間を左右から1つずつ減らして確認する場合",
			"\ttarget = max(rec(l + 1, r), rec(l, r - 1));",
			"",
			"\t// // 例: 区間を2つに分けて試す場合",
			"\t// for (ll i = l; i < r; ++i) {",
			"\t// \tchmax(target, rec(l, i) + rec(i + 1, r));",
			"\t// }",
			"",
			"\treturn target;",
			"}",
			"",
			"int main() {",
			"\tios::sync_with_stdio(false);",
			"\tcin.tie(nullptr);",
			"",
			"\tin(n);",
			"",
			"\td.resize(n);",
			"\trep(i, 0, n) in(d[i]);",
			"",
			"\tdp.assign(n+1, onevec(n+1, -1));",
			"",
			"\tout(rec(0, n));",
			"",
			"\treturn 0;",
			"}"
		],
	}
}