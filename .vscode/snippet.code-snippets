{
	"main": {
		"prefix": "main",
		"body": [
			"#include <bits/stdc++.h>",
			"#define rep(i, a, b) for (ll i = a; i < b; i++)",
			"#define rrep(i, a, b) for (ll i = a; i >= b; i--)",
			"#define fore(i, a) for (auto &i : a)",
			"#define all(x) (x).begin(), (x).end()",
			"#pragma GCC optimize(\"-O3\")",
			"",
			"using namespace std;",
			"using ll = long long;",
			"using ld = long double;",
			"using i128 = __int128_t;",
			"using pll = pair<ll, ll>;",
			"using pld = pair<ld, ld>;",
			"using matrix = vector<vector<ll>>;",
			"using matrixld = vector<vector<ld>>;",
			"using onevec = vector<ll>;",
			"using onevecld = vector<ld>;",
			"using lset = set<ll>;",
			"",
			"const ll INFL = 1LL << 60;",
			"template <class T> bool chmin(T &a, T b) {",
			"  if (a > b) {",
			"    a = b;",
			"    return true;",
			"  }",
			"  return false;",
			"}",
			"template <class T> bool chmax(T &a, T b) {",
			"  if (a < b) {",
			"    a = b;",
			"    return true;",
			"  }",
			"  return false;",
			"}",
			"template <typename T> ll lsize(const T &container) {",
			"  return static_cast<ll>(container.size());",
			"}",
			"template <typename T> bool ifbit(T number, ll bit) {",
			"  return (number & (1LL << bit)) != 0;",
			"}",
			"template <typename T> ll twice(const T &a) { return a * a; }",
			"template <typename T> T bits_count(T v) { return __builtin_popcountll(v); }",
			"",
			"template <typename T> T factorial(T n) {",
			"  T result = 1;",
			"  for (T i = 1; i <= n; ++i) {",
			"    result *= i;",
			"  }",
			"  return result;",
			"}",
			"",
			"template <typename T> T pdistance(const vector<pair<T, T>> &xy, int i, int j) {",
			"  return sqrt(twice(xy[i].first - xy[j].first) +",
			"              twice(xy[i].second - xy[j].second));",
			"}",
			"",
			"template <typename T> void print(T value, int precision) {",
			"  cout << fixed << setprecision(precision) << value << endl;",
			"}",
			"",
			"template <typename... Args> void input(Args &...args) { (cin >> ... >> args); }",
			"",
			"template <typename... Args> void output(const Args &...args) {",
			"  constexpr size_t n = sizeof...(args);",
			"  size_t i = 0;",
			"  ((cout << args << (++i < n ? \" \" : \"\")), ...) << \"\\n\";",
			"}",
			"",
			"const int dx[8] = {1, 0, -1, 0, 1, 1, -1, -1};",
			"const int dy[8] = {0, 1, 0, -1, 1, -1, 1, -1};",
			"/*--------------------------------------------------------",
			"                         \\0w0/ ",
			"                        OwOkaomoji",
			"                     ｡˚ (¦3ꇤ )3 ⋆｡˚✩",
			"----------------------------------------------------------*/",
			"",
			"int main() {",
			"    $1",
			"    ll n;",
			"    cin >> n;",
			"    return 0;",
			"}",
		]
	},
	"bfs": {
		"prefix": "bfs",
		"body": [
			"void bfs(const matrix& G, ll start, vector<ll>& dist) {",
			"    ll n = G.size();",
			"    queue<ll> que;",
			"",
			"    dist[start] = 0; // 初期ノード",
			"    que.push(start);",
			"",
			"    while (!que.empty()) {",
			"        ll v = que.front();",
			"        que.pop();",
			"",
			"        for (ll nv : G[v]) {",
			"            if (dist[nv] != -1) continue; // 訪問済み",
			"            dist[nv] = dist[v] + 1;",
			"            que.push(nv);",
			"        }",
			"    }",
			"}",
			"",
			"int main() {",
			"    $1",
			"    ll N, M; // 頂点数と辺数",
			"    cin >> N >> M;",
			"",
			"    matrix G(N); ",
			"    for (ll i = 0; i < M; ++i) { // 辺の入力",
			"        ll u, v;",
			"        cin >> u >> v;",
			"        u--; v--; // 0-indexedに変換",
			"        G[u].push_back(v);",
			"        G[v].push_back(u); // 無向グラフ",
			"    }",
			"",
			"    vector<ll> dist(N, -1); // 距離配列",
			"    bfs(G, 0, dist); // 頂点0を始点としてBFS実行",
			"",
			"    for (ll v = 0; v < N; ++v) {",
			"        cout << dist[v] << \"\\n\";",
			"    }",
			"",
			"    return 0;",
			"}"
		],
	},
	"bin": {
		"prefix": "bin",
		"body": [
			"ll my_bin(ll ok, ll ng, function<bool(ll)> condition) {",
			"    while (abs(ok - ng) > 1) {",
			"        ll mid = (ok + ng) / 2;",
			"        if (condition(mid)) {",
			"            ok = mid;",
			"        } else {",
			"            ng = mid;",
			"        }",
			"    }",
			"    return ok;",
			"}",
			"",
			"int main() {",
			"    $1",
			"    ll n, q;",
			"    cin >> n >> q;",
			"",
			"    vector<ll> A(n);",
			"    fore(a,A) cin >> a;",
			"    sort(all(A));",
			"",
			"    rep(i,0,q) {",
			"        ll x;",
			"        cin >> x;",
			"",
			"        auto condition = [&](ll mid) { return A[mid] >= x; };",
			"",
			"        ll idx = my_bin(llsize(A), -1, condition);",
			"        cout << n - idx << endl;",
			"    }",
			"",
			"    return 0;",
			"}"
		],
	},
	"divirsions": {
		"prefix": "divisors",
		"body": [
			"vector<ll> calc_divisors(ll N) {",
			" vector<ll> res;",
			"",
			" for (ll i = 1; i * i <= N; ++i) {",
			"  if (N % i != 0) continue;",
			"",
			"  res.push_back(i);",
			"",
			"  if (N / i != i) res.push_back(N / i);",
			" }",
			"",
			" sort(res.begin(), res.end());",
			" return res;",
			"}",
			"    $1",
		]
	},
	"prime_fac": {
		"prefix": "prime_fac",
		"body": [
			"vector<pair<ll, ll>> prime_factorize(ll N) {",
			"    vector<pair<ll, ll>> res;",
			"",
			"    for (ll p = 2; p * p <= N; ++p) {",
			"        if (N % p != 0) {",
			"            continue;",
			"        }",
			"",
			"        ll e = 0;",
			"        while (N % p == 0) {",
			"            ++e;",
			"            N /= p;",
			"        }",
			"",
			"        res.emplace_back(p, e);",
			"    }",
			"",
			"    if (N != 1) {",
			"        res.emplace_back(N, 1);",
			"    }",
			"    return res;",
			"}",
			"",
			"int main() {",
			"    $1",
			"    ll n;",
			"    cin >> n;",
			"    const auto &pf = prime_factorize(n);",
			"    for (const auto &p : pf) {",
			"        cout << p.first << \" \" << p.second << endl;",
			"    }",
			"    return 0;",
			"}"
		]
	},
	"dp": {
		"prefix": "dp",
		"body": [
			"int main() {",
			"    $1",
			" ll n;",
			" cin >> n;",
			"",
			" vector<ll> h(n); ",
			" for (ll i = 0; i < n; ++i) {",
			"  cin >> h[i];",
			" }",
			" vector<ll> dp(n, INFL);",
			"",
			" // 初期条件の設定",
			" dp[0] = 0;",
			"",
			" // ループ",
			" for (ll i = 1; i < n; ++i) {",
			"  chmin(dp[i], dp[i - 1] + abs(h[i] - h[i - 1]));",
			" }",
			"",
			" // 結果の出力",
			" cout << dp[n - 1] << endl;",
			"",
			" return 0;",
			"}",
		]
	},
	"findstr": {
		"prefix": "findstr",
		"body": [
			"struct findstr {",
			"    string S;",
			"    ll N;",
			"    findstr() {}",
			"    findstr(string s) { init(s); }",
			"    void init(string s) {",
			"        S = s;",
			"        N = S.length();",
			"        init();",
			"    }",
			"    // get the nearest index for the char",
			"    vector<ll> left[26], right[26];",
			"    inline void init() {",
			"        rep(c, 0, 25) {",
			"            right[c].resize(N);",
			"            right[c][N - 1] = INFI;",
			"        }",
			"        rrep(i, N - 2, 0) {",
			"            rep(c, 0, 25) right[c][i] = right[c][i + 1];",
			"            right[S[i + 1]][i] = i + 1;",
			"        }",
			"        rep(c, 0, 25) {",
			"            left[c].resize(N);",
			"            left[c][0] = -1;",
			"        }",
			"        rep(i, 1, N - 1) {",
			"            rep(c, 0, 25) left[c][i] = left[c][i - 1];",
			"            left[S[i - 1]][i] = i - 1;",
			"        }",
			"    }",
			"    inline ll goright(ll cu, ll c) {",
			"        if (cu == INFI) return INFI;",
			"        if (cu < 0) {",
			"            if (S[0] == c) return 0;",
			"            cu = 0;",
			"        }",
			"        return right[c][cu];",
			"    }",
			"    inline ll goleft(ll cu, ll c) {",
			"        if (cu < 0) return cu;",
			"        return left[c][cu];",
			"    }",
			"};",
			"",
			"int main() {",
			"    $1",
			"    ll N;",
			"    string S;",
			"    cin >> N >> S;",
			"",
			"    fore(c, S) c -= '0';",
			"    findstr sm(S);",
			"",
			"    ll ans = 0;",
			"    rep(x0, 0, 9) rep(x1, 0, 9) rep(x2, 0, 9) {",
			"        ll cu = -1;",
			"        cu = sm.goright(cu, x0);",
			"        cu = sm.goright(cu, x1);",
			"        cu = sm.goright(cu, x2);",
			"        if (cu < INFI) ans++;",
			"    }",
			"    cout << ans << endl;",
			"}"
		]
	},
	"findpll": {
		"prefix": "findpll",
		"body": [
			"int main() {",
			"    $1",
			"    const ll max_this = 1000000;",
			"    ll n;",
			"    cin >> n;",
			"",
			"    vector<ll> x_n(n);",
			"    vector<ll> y_n(n);",
			"    set<pll> isin; ",
			"",
			"    for (ll i = 0; i < n; ++i) {",
			"        cin >> x_n[i] >> y_n[i];",
			"        isin.insert(make_pair(x_n[i], y_n[i])); // 座標をセットに挿入",
			"    }",
			"    // 座標が含まれるかをチェックするラムダ関数",
			"    auto check = [&](ll x, ll y) -> bool {",
			"        if (x < 0 || x > max_this || y < 0 || y > max_this) {",
			"            return false; // 範囲外",
			"        }",
			"        return isin.count(make_pair(x, y)) > 0; ",
			"    };",
			"",
			"    // 座標を入力してチェック",
			"    ll a, b;",
			"    cin >> a >> b;",
			"    if (check(a, b)) {",
			"        cout << \"Yes\" << endl;",
			"    } else {",
			"        cout << \"No\" << endl;",
			"    }",
			"",
			"    return 0;",
			"}"
		]
	},
	"tri": {
		"prefix": "tri",
		"body": [
			"ld my_tri(ld ok, ld ng, function<ld(ld)> f) {",
			" while (abs(ok - ng) > 1e-11) {",
			"   ld mid_l = (ok + ng * 2) / 3;",
			"   ld mid_r = (ok * 2 + ng) / 3;",
			"   if (f(mid_l) > f(mid_r)) {",
			"     ng = mid_l;",
			"   } else {",
			"     ok = mid_r;",
			"   }",
			" }",
			" return ok;",
			"}",
			"",
			"int main() {",
			"    $1",
			" ld p;",
			" cin >> p;",
			"",
			" auto f = [&](ld mid) {",
			"   return mid + p / pow(2, mid / 1.5);",
			" };",
			"",
			" ld idx = my_tri(INFL, 0, f);",
			" print(f(idx), 10);",
			" return 0;",
			"}",
		]
	},
	"dfs_one": {
		"prefix": "dfs_one",
		"body": [
			"class DFS {",
			"public:",
			"vector<bool> seen;",
			"vector<ll> f_o, l_o;",
			"ll ptr;",
			"ll cnt;",
			"",
			"DFS(const matrix &G) : seen(G.size(), false), f_o(G.size(), 0), l_o(G.size(), 0), ptr(0), cnt(0) {",
			"for (ll i = 0; i < (ll)G.size(); i++) {",
			"if (!seen[i]) {",
			"cnt++;",
			"dfs(G, i);",
			"}",
			"}",
			"}",
			"",
			"void dfs(const matrix &G, ll v) {",
			"seen[v] = true;",
			"f_o[v] = ++ptr;",
			"for (ll n_v : G[v]) {",
			"if (!seen[n_v]) dfs(G, n_v);",
			"}",
			"l_o[v] = ++ptr;",
			"}",
			"",
			"void output() const {",
			"for (ll i = 0; i < (ll)f_o.size(); i++) {",
			"printf(\"%lld %lld %lld\\n\", i + 1, f_o[i], l_o[i]);",
			"}",
			"printf(\"%lld\\n\", cnt);",
			"}",
			"};",
			"",
			"int main() {",
			"ll n;",
			"cin >> n;",
			"matrix G(n);",
			"for (ll i = 0; i < n; i++) {",
			"ll u, k;",
			"cin >> u >> k;",
			"u--;",
			"for (ll j = 0; j < k; j++) {",
			"ll v;",
			"cin >> v;",
			"v--;",
			"G[u].push_back(v);",
			"}",
			"}",
			"DFS dfs_solver(G);",
			"dfs_solver.output();",
			"return 0;",
			"}"
		]
	},
	"dfs_matrix": {
		"prefix": "dfs_matrix",
		"body": [
			"class DFS {",
			"public:",
			"vector<vector<bool>> seen;",
			"vector<vector<ll>> f_o, l_o;",
			"ll ptr;",
			"ll cnt;",
			"",
			"DFS(const matrix &G)",
			": seen(G.size(), vector<bool>(G[0].size(), false)),",
			"f_o(G.size(), vector<ll>(G[0].size(), 0)),",
			"l_o(G.size(), vector<ll>(G[0].size(), 0)), ptr(0), cnt(0) {",
			"for (ll i = 0; i < (ll)G.size(); i++)",
			"rep(j, 0, G[0].size()) {",
			"if (!seen[i][j] && G[i][j] == 1) {",
			"cnt++;",
			"dfs(G, i, j);",
			"}",
			"}",
			"}",
			"",
			"void dfs(const matrix &G, ll h, ll w) {",
			"seen[h][w] = true;",
			"f_o[h][w] = ++ptr;",
			"rep(i, 0, 8) {",
			"ll nh = h + dx[i];",
			"ll nw = w + dy[i];",
			"if (nh >= 0 && nh < (ll)G.size() && nw >= 0 && nw < (ll)G[0].size()) {",
			"if (!seen[nh][nw] && G[nh][nw] == 1) {",
			"dfs(G, nh, nw);",
			"}",
			"}",
			"}",
			"l_o[h][w] = ++ptr;",
			"}",
			"",
			"void output() const { cout << cnt << endl; }",
			"};",
			"",
			"int main() {",
			"ll W, H;",
			"cin >> W >> H;",
			"while (!(!W && !H)) {",
			"matrix G(H);",
			"rep(i, 0, H) rep(j, 0, W) {",
			"ll v;",
			"cin >> v;",
			"G[i].push_back(v);",
			"}",
			"DFS dfs_solver(G);",
			"dfs_solver.output();",
			"cin >> W >> H;",
			"}",
			"return 0;",
			"}"
		]
	},
	"dfs_tree": {
		"prefix": "dfs_tree",
		"body": [
			"class DFS {",
			"    public:",
			"        vector<bool> seen;",
			"        onevec depth;",
			"        const matrix &G;",
			"",
			"        DFS(const matrix &G) : G(G), seen(G.size(), false), depth(G.size(), 0) {",
			"            dfs(0, -1, 0);",
			"        }",
			"",
			"        void dfs(ll v, ll parent, ll d) {",
			"            seen[v] = true;",
			"            depth[v] = d;",
			"            for (auto &u : G[v]) {",
			"                if (u == parent) continue;",
			"                dfs(u, v, d + 1);",
			"            }",
			"        }",
			"",
			"        void output() const {",
			"            rep(i, 0, depth.size()) {",
			"                cout << depth[i];",
			"                if (i < depth.size() - 1) {",
			"                    cout << ' ';",
			"                } else {",
			"                    cout << endl;",
			"                }",
			"            }",
			"        }",
			"};",
			"",
			"int main() {",
			"    ll n;",
			"    cin >> n;",
			"    matrix G(n);",
			"    rep(i, 0, n - 1) {",
			"        ll u, k;",
			"        cin >> u >> k",
			"}"
		]
	},
	"dfs_matrix_tree": {
		"prefix": "dfs_matrix_tree",
		"body": [
			"class DFS {",
			"    public:",
			"        vector<vector<bool>> seen;",
			"        ll max_depth;",
			"",
			"        DFS(const matrix &G)",
			"                : seen(G.size(), vector<bool>(G[0].size(), false)), max_depth(0) {",
			"            for (ll i = 0; i < (ll)G.size(); i++) {",
			"                for (ll j = 0; j < (ll)G[0].size(); j++) {",
			"                    if (G[i][j] == 1) {",
			"                        dfs(G, i, j, 1);",
			"                    }",
			"                }",
			"            }",
			"        }",
			"",
			"        void dfs(const matrix &G, ll h, ll w, ll d) {",
			"            seen[h][w] = true;",
			"            chmax(max_depth, d);",
			"",
			"            rep(i, 0, 4) {",
			"                ll nh = h + dx[i];",
			"                ll nw = w + dy[i];",
			"                if (nh >= 0 && nh < (ll)G.size() && nw >= 0 && nw < (ll)G[0].size()) {",
			"                    if (!seen[nh][nw] && G[nh][nw] == 1) {",
			"                        dfs(G, nh, nw, d + 1);",
			"                    }",
			"                }",
			"            }",
			"            seen[h][w] = false;",
			"        }",
			"",
			"        void output() const { cout << max_depth << endl; }",
			"};",
			"",
			"int main() {",
			"    ll W, H;",
			"    cin >> W >> H;",
			"    matrix G(H, vector<ll>(W));",
			"    rep(i, 0, H) rep(j, 0, W) { cin >> G[i][j]; }",
			"    DFS dfs_solver(G);",
			"    dfs_solver.output();",
			"    return 0;",
			"}"
		]
	},
	"bfs_matrix": {
		"prefix": "bfs_matrix",
		"body": [
			"void bfs_matrix(const vector<string> &field, ll sx, ll sy, matrix &dist) {",
			"    dist[sx][sy] = 0; // スタートを 0 に",
			"",
			"    // 探索中に各マスはどのマスから来たのかを表す配列",
			"    // (最短経路長を知るだけなら、これは不要)",
			"    vector<vector<ll>> prev_x(field.size(), vector<ll>(field[0].size(), -1));",
			"    vector<vector<ll>> prev_y(field.size(), vector<ll>(field[0].size(), -1));",
			"    // 「一度見た頂点」のうち「まだ訪れていない頂点」を表すキュー",
			"    queue<pair<ll, ll>> que;",
			"    que.push(make_pair(sx, sy)); // スタートを push",
			"",
			"    /* 幅優先探索を実施 */",
			"",
			"    /* キューが空になるまで */",
			"    while (!que.empty()) {",
			"        pair<ll, ll> current_pos = que.front(); // キューの先頭を見る (C++ ではこれをしても pop しない)",
			"        ll x = current_pos.first;",
			"        ll y = current_pos.second;",
			"        que.pop(); // キューから pop を忘れずに",
			"",
			"        // 隣接頂点を探索",
			"        for (ll direction = 0; direction < 4; ++direction) {",
			"            ll next_x = x + dx[direction];",
			"            ll next_y = y + dy[direction];",
			"            if (next_x < 0 || next_x >= field.size() || next_y < 0 || next_y >= field[0].size())",
			"                continue; // 場外アウトならダメ",
			"            if (field[next_x][next_y] == '#')",
			"                continue; // 壁はダメ",
			"",
			"            // まだ見ていない頂点なら push",
			"            if (dist[next_x][next_y] == -1) {",
			"                que.push(make_pair(next_x, next_y));",
			"                dist[next_x][next_y] = dist[x][y] + 1; // (next_x, next_y) の距離も更新",
			"                prev_x[next_x][next_y] = x; // どの頂点から情報が伝播して来たか、縦方向の座標をメモ",
			"                prev_y[next_x][next_y] = y; // どの頂点から情報が伝播して来たか、横方向の座標をメモ",
			"            }",
			"        }",
			"    }",
			"}",
			"int main() {",
			"",
			"    /* 入力受け取り */",
			"",
			"    /* 縦と横の長さ */",
			"    ll height, width;",
			"    cin >> height >> width;",
			"    ll sx, sy, gx, gy;",
			"    input(sx, sy, gx, gy);",
			"    sx--; sy--; gx--; gy--;",
			"    /* 盤面 */",
			"    vector<string> field(height);",
			"    for (ll h = 0; h < height; ++h)",
			"        cin >> field[h];",
			"",
			"    /* スタート地点とゴール地点 */",
			"    // ll sx, sy, gx, gy;",
			"    // for (ll h = 0; h < height; ++h) {",
			"    //   for (ll w = 0; w < width; ++w) {",
			"    //     if (field[h][w] == 'S') {",
			"    //       sx = h;",
			"    //       sy = w;",
			"    //     }",
			"    //     if (field[h][w] == 'G') {",
			"    //       gx = h;",
			"    //       gy = w;",
			"    //     }",
			"    //   }",
			"    // }",
			"",
			"    /* 幅優先探索の初期設定 */",
			"",
			"    // 各セルの最短距離 (訪れていないところは -1 としておく)",
			"    vector<vector<ll>> dist(height, vector<ll>(width, -1));",
			"    bfs_matrix(field, sx, sy, dist);",
			"",
			"    /* 結果出力 */",
			"",
			"    // ll x = gx, y = gy;",
			"    // while (x != -1 && y != -1) {",
			"    //   field[x][y] = 'o'; // 通過したことを示す",
			"",
			"    //   // 前の頂点へ行く",
			"    //   ll px = prev_x[x][y];",
			"    //   ll py = prev_y[x][y];",
			"    //   x = px, y = py;",
			"    // }",
			"    // for (ll h = 0; h < height; ++h) {",
			"    //   for (ll w = 0; w < width; ++w) {",
			"    //     cout << std::setw(3) << field[h][w];",
			"    //   }",
			"    //   cout << endl;",
			"    // }",
			"",
			"    output(dist[gx][gy]);",
			"    return 0;",
			"}",
		]
	}
}