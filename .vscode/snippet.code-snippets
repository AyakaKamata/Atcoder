{
	"main": {
		"prefix": "main",
		"body": [
			"#include<bits/stdc++.h>",
			"#define rep(i,a,b) for(int i=a;i<b;i++)",
			"#define rrep(i,a,b) for(int i=a;i>=b;i--)",
			"#define fore(i,a) for(auto &i:a)",
			"#define all(x) (x).begin(),(x).end()",
			"#pragma GCC optimize (\"-O3\")",
			"",
			"using namespace std;",
			"using ll = long long;",
			"using i128 = __int128_t;",
			"using pint = pair<int, int>;",
			"",
			"const int INFI = INT_MAX / 2;",
			"const ll INFL = 1LL << 60;",
			"template <class T> bool chmin(T &a, T b) {",
			"    if (a > b) {",
			"        a = b;",
			"        return true;",
			"    }",
			"    return false;",
			"}",
			"template <class T> bool chmax(T &a, T b) {",
			"    if (a < b) {",
			"        a = b;",
			"        return true;",
			"    }",
			"    return false;",
			"}",
			"/*--------------------------------------------------------",
			"                         \\0w0/ ",
			"                        OwOkaomoji",
			"                     ｡˚ (¦3ꇤ )3 ⋆｡˚✩",
			"----------------------------------------------------------*/",
			"",
			"int main() {",
			"    $1",
			"    return 0;",
			"}",
		]
	},
	"bfs": {
		"prefix": "bfs",
		"body": [
			"using Graph = vector<vector<int>>;",
			"",
			"void bfs(const Graph& G, int start, vector<int>& dist) {",
			"    int n = G.size();",
			"    queue<int> que;",
			"",
			"    dist[start] = 0; // 初期ノード",
			"    que.push(start);",
			"",
			"    while (!que.empty()) {",
			"        int v = que.front();",
			"        que.pop();",
			"",
			"        for (int nv : G[v]) {",
			"            if (dist[nv] != -1) continue; // 訪問済み",
			"            dist[nv] = dist[v] + 1;",
			"            que.push(nv);",
			"        }",
			"    }",
			"}",
			"",
			"int main() {",
			"    $1",
			"    int N, M; // 頂点数と辺数",
			"    cin >> N >> M;",
			"",
			"    Graph G(N); ",
			"    for (int i = 0; i < M; ++i) { // 辺の入力",
			"        int u, v;",
			"        cin >> u >> v;",
			"        u--; v--; // 0-indexedに変換",
			"        G[u].push_back(v);",
			"        G[v].push_back(u); // 無向グラフ",
			"    }",
			"",
			"    vector<int> dist(N, -1); // 距離配列",
			"    bfs(G, 0, dist); // 頂点0を始点としてBFS実行",
			"",
			"    for (int v = 0; v < N; ++v) {",
			"        cout << dist[v] << \"\\n\";",
			"    }",
			"",
			"    return 0;",
			"}"
		],
	},
	"bin": {
		"prefix": "bin",
		"body": [
			"ll my_bin(ll ok, ll ng, function<bool(ll)> condition) {",
			"    while (abs(ok - ng) > 1) {",
			"        ll mid = (ok + ng) / 2;",
			"        if (condition(mid)) {",
			"            ok = mid;",
			"        } else {",
			"            ng = mid;",
			"        }",
			"    }",
			"    return ok;",
			"}",
			"",
			"int main() {",
			"    $1",
			"    ll n, q;",
			"    cin >> n >> q;",
			"",
			"    vector<int> A(n);",
			"    for (auto &&a : A) cin >> a;",
			"    sort(A.begin(), A.end());",
			"",
			"    for (ll i = 0; i < q; i++) {",
			"        int x;",
			"        cin >> x;",
			"",
			"        auto condition = [&](ll mid) { return A[mid] >= x; };",
			"",
			"        ll idx = my_bin(n, -1, condition);",
			"        cout << n - idx << endl;",
			"    }",
			"",
			"    return 0;",
			"}"
		],
	},
	"divirsions": {
		"prefix": "divisors",
		"body": [
			"vector<long long> calc_divisors(long long N) {",
			" vector<long long> res;",
			"",
			" for (long long i = 1; i * i <= N; ++i) {",
			"  if (N % i != 0) continue;",
			"",
			"  res.push_back(i);",
			"",
			"  if (N / i != i) res.push_back(N / i);",
			" }",
			"",
			" sort(res.begin(), res.end());",
			" return res;",
			"}",
			"    $1",
		]
	},
	"prime_fac": {
		"prefix": "prime_fac",
		"body": [
			"vector<pair<long long, long long>> prime_factorize(long long N) {",
			"    vector<pair<long long, long long>> res;",
			"",
			"    for (long long p = 2; p * p <= N; ++p) {",
			"        if (N % p != 0) {",
			"            continue;",
			"        }",
			"",
			"        int e = 0;",
			"        while (N % p == 0) {",
			"            ++e;",
			"            N /= p;",
			"        }",
			"",
			"        res.emplace_back(p, e);",
			"    }",
			"",
			"    if (N != 1) {",
			"        res.emplace_back(N, 1);",
			"    }",
			"    return res;",
			"}",
			"",
			"int main() {",
			"    $1",
			"    int n;",
			"    cin >> n;",
			"    const auto &pf = prime_factorize(n);",
			"    for (const auto &p : pf) {",
			"        cout << p.first << \" \" << p.second << endl;",
			"    }",
			"    return 0;",
			"}"
		]
	},
	"dp": {
		"prefix": "dp",
		"body": [
			"int main() {",
			"    $1",
			" int n;",
			" cin >> n;",
			"",
			" vector<int> h(n); ",
			" for (int i = 0; i < n; ++i) {",
			"  cin >> h[i];",
			" }",
			" vector<ll> dp(n, INF);",
			"",
			" // 初期条件の設定",
			" dp[0] = 0;",
			"",
			" // ループ",
			" for (int i = 1; i < n; ++i) {",
			"  chmin(dp[i], dp[i - 1] + abs(h[i] - h[i - 1]));",
			" }",
			"",
			" // 結果の出力",
			" cout << dp[n - 1] << endl;",
			"",
			" return 0;",
			"}",
		]
	},
	"findstr": {
		"prefix": "findstr",
		"body": [
			"struct findstr {",
			"    string S;",
			"    int N;",
			"    findstr() {}",
			"    findstr(string s) { init(s); }",
			"    void init(string s) {",
			"        S = s;",
			"        N = S.length();",
			"        init();",
			"    }",
			"    // get the nearest index for the char",
			"    vector<int> left[26], right[26];",
			"    inline void init() {",
			"        rep(c, 0, 25) {",
			"            right[c].resize(N);",
			"            right[c][N - 1] = INFI;",
			"        }",
			"        rrep(i, N - 2, 0) {",
			"            rep(c, 0, 25) right[c][i] = right[c][i + 1];",
			"            right[S[i + 1]][i] = i + 1;",
			"        }",
			"        rep(c, 0, 25) {",
			"            left[c].resize(N);",
			"            left[c][0] = -1;",
			"        }",
			"        rep(i, 1, N - 1) {",
			"            rep(c, 0, 25) left[c][i] = left[c][i - 1];",
			"            left[S[i - 1]][i] = i - 1;",
			"        }",
			"    }",
			"    inline int goright(int cu, int c) {",
			"        if (cu == INFI) return INFI;",
			"        if (cu < 0) {",
			"            if (S[0] == c) return 0;",
			"            cu = 0;",
			"        }",
			"        return right[c][cu];",
			"    }",
			"    inline int goleft(int cu, int c) {",
			"        if (cu < 0) return cu;",
			"        return left[c][cu];",
			"    }",
			"};",
			"",
			"int main() {",
			"    $1",
			"    int N;",
			"    string S;",
			"    cin >> N >> S;",
			"",
			"    fore(c, S) c -= '0';",
			"    findstr sm(S);",
			"",
			"    int ans = 0;",
			"    rep(x0, 0, 9) rep(x1, 0, 9) rep(x2, 0, 9) {",
			"        int cu = -1;",
			"        cu = sm.goright(cu, x0);",
			"        cu = sm.goright(cu, x1);",
			"        cu = sm.goright(cu, x2);",
			"        if (cu < INFI) ans++;",
			"    }",
			"    cout << ans << endl;",
			"}"
		]
	},
	"findpint": {
		"prefix": "findpint",
		"body": [
			"int main() {",
			"    $1",
			"    const int max_this = 1000000;",
			"    int n;",
			"    cin >> n;",
			"",
			"    vector<int> x_n(n);",
			"    vector<int> y_n(n);",
			"    set<pint> isin; ",
			"",
			"    for (int i = 0; i < n; ++i) {",
			"        cin >> x_n[i] >> y_n[i];",
			"        isin.insert(make_pair(x_n[i], y_n[i])); // 座標をセットに挿入",
			"    }",
			"    // 座標が有効かをチェックするラムダ関数",
			"    auto check = [&](int x, int y) -> bool {",
			"        if (x < 0 || x > max_this || y < 0 || y > max_this) {",
			"            return false; // 範囲外",
			"        }",
			"        return isin.count(make_pair(x, y)) > 0; ",
			"    };",
			"",
			"    // テスト用の座標を入力してチェック",
			"    int a, b;",
			"    cin >> a >> b;",
			"    if (check(a, b)) {",
			"        cout << \"Yes\" << endl;",
			"    } else {",
			"        cout << \"No\" << endl;",
			"    }",
			"",
			"    return 0;",
			"}"
		]
	}
}