{
	"main": {
		"prefix": "main",
		"body": [
			"#include <bits/stdc++.h>",
			"#define rep(i, a, b) for (ll i = a; i < b; i++)",
			"#define rrep(i, a, b) for (ll i = a; i >= b; i--)",
			"#define fore(i, a) for (auto &i : a)",
			"#define all(x) (x).begin(), (x).end()",
			"#define YES cout << \"Yes\" << endl",
			"#define NO cout << \"No\" << endl",
			"#define YN { cout << \"Yes\" << endl; } else { cout << \"No\" << endl; } // if(a==b)YN;",
			"#define FAIL cout << -1 << endl",
			"#pragma GCC optimize(\"-O3\")",
			"",
			"using namespace std;",
			"using ll = long long;",
			"using ull = unsigned long long;",
			"using ld = long double;",
			"using i128 = __int128_t;",
			"using pll = pair<ll, ll>;",
			"using pld = pair<ld, ld>;",
			"using matrix = vector<vector<ll>>;",
			"using matrixld = vector<vector<ld>>;",
			"using matrixb = vector<vector<bool>>;",
			"using onevec = vector<ll>;",
			"using onevecld = vector<ld>;",
			"using onevecb = vector<bool>;",
			"using lset = set<ll>;",
			"",
			"const ll INFL = 1LL << 60;",
			"template <class T> T chmin(T &a, T b) {",
			"  if (a > b) {",
			"    a = b;",
			"  }",
			"  return a;",
			"}",
			"template <class T> T chmax(T &a, T b) {",
			"  if (a < b) {",
			"    a = b;",
			"  }",
			"  return a;",
			"}",
			"template <typename T> ll lsize(const T &container) {",
			"  return static_cast<ll>(container.size());",
			"}",
			"template <typename T> bool ifbit(T number, ll bit) {",
			"  return (number & (1LL << bit)) != 0;",
			"}",
			"template <typename T> T twice(const T &a) { return a * a; }",
			"template <typename T> T bits_count(T v) { return __builtin_popcountll(v); }",
			"",
			"template <typename T> T factorial(T n) {",
			"  T result = 1;",
			"  for (T i = 1; i <= n; ++i) {",
			"    result *= i;",
			"  }",
			"  return result;",
			"}",
			"",
			"template <typename T> T pdistance(const vector<pair<T, T>> &xy, int i, int j) {",
			"  return sqrt(twice(xy[i].first - xy[j].first) +",
			"              twice(xy[i].second - xy[j].second));",
			"}",
			"template <typename T>",
			"int isperp(const vector<pair<T, T>> &xyz, int i, int j, int k) {",
			"    T dx1 = xyz[i].first - xyz[j].first, dy1 = xyz[i].second - xyz[j].second;",
			"    T dx2 = xyz[k].first - xyz[j].first, dy2 = xyz[k].second - xyz[j].second;",
			"",
			"    T dot = dx1 * dx2 + dy1 * dy2;",
			"",
			"    return (dot > 0) ? 0 : (dot == 0) ? 1 : -1;",
			"}",
			"",
			"template <typename T>",
			"T crossp(const vector<pair<T, T>> &xyz, int i, int j, int k) {",
			"    T dx1 = xyz[i].first - xyz[j].first, dy1 = xyz[i].second - xyz[j].second;",
			"    T dx2 = xyz[k].first - xyz[j].first, dy2 = xyz[k].second - xyz[j].second;",
			"",
			"    return dx1 * dy2 - dy1 * dx2;",
			"}",
			"",
			"template <typename T>",
			"T mod_exp(T base, T exp, T mod) {",
			"    T result = 1;",
			"    while (exp > 0) {",
			"        if (exp & 1) result = (result * base) % mod;",
			"        base = (base * base) % mod;",
			"        exp >>= 1;",
			"    }",
			"    return result;",
			"}",
			"",
			"template <typename T> void print(T value, int precision) {",
			"  cout << fixed << setprecision(precision) << value << endl;",
			"}",
			"",
			"template <typename... Args> void in(Args &...args) { (cin >> ... >> args); }",
			"",
			"template <typename... Args> void out(const Args &...args) {",
			"  constexpr size_t n = sizeof...(args);",
			"  size_t i = 0;",
			"  ((cout << args << (++i < n ? \" \" : \"\")), ...) << \"\\n\";",
			"}",
			"",
			"const int dx[8] = {1, 0, -1, 0, 1, 1, -1, -1};",
			"const int dy[8] = {0, 1, 0, -1, 1, -1, 1, -1};",
			"string strrep(const string &s, const string &from, const string &to) {",
			"",
			"    unordered_map<char, char> trans;",
			"    for (size_t i = 0; i < from.size(); ++i) {",
			"        trans[from[i]] = to[i];",
			"    }",
			"",
			"    string res = s;",
			"    for (char &c : res) {",
			"        if (trans.count(c)) {",
			"            c = trans[c];",
			"        }",
			"    }",
			"    return res;",
			"}",
			"template <typename T> bool isprime(T N) {",
			" if (N < 2)",
			"  return false;",
			" for (T i = 2; i * i <= N; i++) {",
			" if (N % i == 0)",
			"   return false;",
			" }",
			" return true;",
			"}",
			"template <typename T>",
			"using min_priority_queue = priority_queue<T, vector<T>, greater<T>>;",
			"vector<pair<char, int>> rle(const string &s) {",
			"    vector<pair<char, int>> res;",
			"    for (int i = 0, cnt; i < s.size(); i += cnt) {",
			"        cnt = 1;",
			"        while (i + cnt < s.size() && s[i] == s[i + cnt])",
			"            cnt++;",
			"        res.emplace_back(s[i], cnt);",
			"    }",
			"    return res;",
			"}",
			"template <typename T> void outvec(vector<T> vec) {",
			" rep(i, 0, lsize(vec)) {",
			"  cout << vec[i] << (i == lsize(vec) - 1 ? \"\\n\" : \" \");",
			" }",
			"}",
			"// 入力の2次元行列の累積和（プレフィックスサム）を計算する関数",
			"// 1-indexになる",
			"// ans=(c,d)-(a-1,d)-(c,b-1)+(a-1,b-1)",
			"template <typename T>",
			"vector<vector<T>> CumsumSquare(const vector<vector<T>> &mat) {",
			"  T n = mat.size();                  // 行数",
			"  T m = (n > 0 ? mat[0].size() : 0);   // 列数",
			"  vector<vector<T>> sum(n+1, vector<T>(m+1, 0));",
			"",
			"  for (T i = 1; i < n+1; i++) {",
			"    for (T j = 1; j < m+1; j++) {",
			"      sum[i][j] = mat[i-1][j-1];",
			"      sum[i][j] += sum[i - 1][j];",
			"      sum[i][j] += sum[i][j - 1];",
			"      sum[i][j] -= sum[i - 1][j - 1];",
			"    }",
			"  }",
			"",
			"  return sum;",
			"}",
			"// a^n mod を計算する",
			"long long modpow(long long a, long long n, long long mod) {",
			" long long res = 1;",
			" while (n > 0) {",
			"  if (n & 1) res = res * a % mod;",
			"  a = a * a % mod;",
			"  n >>= 1;",
			" }",
			" return res;",
			"}",
			"// Fermatの小定理を利用して a の逆元を求める (mod が素数の場合)",
			"ll modinv(ll a, ll mod) { return modpow(a, mod - 2, mod); }",
			"",
			"/*--------------------------------------------------------",
			"                         \\0w0/ ",
			"                        OwOkaomoji",
			"                     ｡˚ (¦3ꇤ )3 ⋆｡˚✩",
			"----------------------------------------------------------*/",
			"",
			"int main() {",
			"    ios::sync_with_stdio(false);",
			"    cin.tie(nullptr);",
			"    $1",
			"    ll n;",
			"    in(n);",
			"    return 0;",
			"}",
		]
	},
	"bfs": {
		"prefix": "bfs",
		"body": [
			"void bfs(const matrix& G, ll start, vector<ll>& dist) {",
			"    ll n = G.size();",
			"    vector<bool> visited(n, false); // visited配列の初期化",
			"",
			"    queue<ll> que;",
			"    dist[start] = 0; // 初期ノードの距離を0に設定",
			"    visited[start] = true; // 初期ノードを訪問済みに設定",
			"    que.push(start);",
			"",
			"    while (!que.empty()) {",
			"        ll v = que.front();",
			"        que.pop();",
			"",
			"        for (ll nv : G[v]) {",
			"            if (visited[nv]) continue; // すでに訪問済みのノードはスキップ",
			"            visited[nv] = true; // ノードを訪問済みに設定",
			"            dist[nv] = dist[v] + 1; // 距離を更新",
			"            que.push(nv);",
			"        }",
			"    }",
			"}",
			"",
			"int main() {",
			"    ll N, M; // 頂点数と辺数",
			"    cin >> N >> M;",
			"",
			"    matrix G(N);",
			"    for (ll i = 0; i < M; ++i) { // 辺の入力",
			"        ll u, v;",
			"        cin >> u >> v;",
			"        u--; v--; // 0-indexedに変換",
			"        G[u].push_back(v);",
			"        G[v].push_back(u); // 無向グラフの場合",
			"    }",
			"",
			"    vector<ll> dist(N, -1); // 距離配列の初期化",
			"    bfs(G, 0, dist); // 頂点0を始点としてBFSを実行",
			"",
			"    for (ll v = 0; v < N; ++v) {",
			"        cout << dist[v] << \"\\n\";",
			"    }",
			"",
			"    return 0;",
			"}"
		],
	},
	"bin": {
		"prefix": "bin",
		"body": [
			"ll my_bin(ll ok, ll ng, function<bool(ll)> condition) {",
			"    while (abs(ok - ng) > 1) {",
			"        ll mid = (ok + ng) / 2;",
			"        if (condition(mid)) {",
			"            ok = mid;",
			"        } else {",
			"            ng = mid;",
			"        }",
			"    }",
			"    return ok;",
			"}",
			"",
			"int main() {",
			"    $1",
			"    ll n, q;",
			"    cin >> n >> q;",
			"",
			"    vector<ll> A(n);",
			"    fore(a,A) cin >> a;",
			"    sort(all(A));",
			"",
			"    rep(i,0,q) {",
			"        ll x;",
			"        cin >> x;",
			"",
			"        auto condition = [&](ll mid) { return A[mid] >= x; };",
			"",
			"        ll idx = my_bin(lsize(A), -1, condition);",
			"        cout << n - idx << endl;",
			"    }",
			"",
			"    return 0;",
			"}"
		],
	},
	"divisors": {
		"prefix": "divisors",
		"body": [
			"vector<ll> calc_divisors(ll N) {",
			" vector<ll> res;",
			"",
			" for (ll i = 1; i * i <= N; ++i) {",
			"  if (N % i != 0) continue;",
			"",
			"  res.push_back(i);",
			"",
			"  if (N / i != i) res.push_back(N / i);",
			" }",
			"",
			" sort(res.begin(), res.end());",
			" return res;",
			"}",
			"    $1",
		]
	},
	"countdiv": {
		"prefix": "count_div",
		"body": [
			"// 約数の個数を求める関数",
			"vector<long long> count_divisors(long long N) {",
			"    vector<long long> divisors(N + 1, 0); // 初期化（全て 0）",
			"",
			"    // 各数値 i に対して、その倍数にカウントを追加",
			"    for (long long i = 1; i <= N; i++) {",
			"        for (long long j = i; j <= N; j += i) {",
			"            divisors[j]++; // j は i の倍数だから約数にカウント",
			"        }",
			"    }",
			"",
			"    return divisors;",
			"}"
		],
	},
	"prime_fac": {
		"prefix": "prime_fac",
		"body": [
			"vector<pair<ll, ll>> prime_factorize(ll N) {",
			"    vector<pair<ll, ll>> res;",
			"",
			"    for (ll p = 2; p * p <= N; ++p) {",
			"        if (N % p != 0) {",
			"            continue;",
			"        }",
			"",
			"        ll e = 0;",
			"        while (N % p == 0) {",
			"            ++e;",
			"            N /= p;",
			"        }",
			"",
			"        res.emplace_back(p, e);",
			"    }",
			"",
			"    if (N != 1) {",
			"        res.emplace_back(N, 1);",
			"    }",
			"    return res;",
			"}",
			"",
			"int main() {",
			"    $1",
			"    ll n;",
			"    cin >> n;",
			"    const auto &pf = prime_factorize(n);",
			"    for (const auto &p : pf) {",
			"        cout << p.first << \" \" << p.second << endl;",
			"    }",
			"    return 0;",
			"}"
		]
	},
	"dp": {
		"prefix": "dp",
		"body": [
			"int main() {",
			"    $1",
			" ll n;",
			" cin >> n;",
			"",
			" vector<ll> h(n); ",
			" for (ll i = 0; i < n; ++i) {",
			"  cin >> h[i];",
			" }",
			" vector<ll> dp(n, INFL);",
			"",
			" // 初期条件の設定",
			" dp[0] = 0;",
			"",
			" // ループ",
			" for (ll i = 1; i < n; ++i) {",
			"  chmin(dp[i], dp[i - 1] + abs(h[i] - h[i - 1]));",
			" }",
			"",
			" // 結果の出力",
			" cout << dp[n - 1] << endl;",
			"",
			" return 0;",
			"}",
		]
	},
	"findstr": {
		"prefix": "findstr",
		"body": [
			"struct findstr {",
			"    string S;",
			"    ll N;",
			"    findstr() {}",
			"    findstr(string s) { init(s); }",
			"    void init(string s) {",
			"        S = s;",
			"        N = S.length();",
			"        init();",
			"    }",
			"    // get the nearest index for the char",
			"    vector<ll> left[26], right[26];",
			"    inline void init() {",
			"        rep(c, 0, 25) {",
			"            right[c].resize(N);",
			"            right[c][N - 1] = INFI;",
			"        }",
			"        rrep(i, N - 2, 0) {",
			"            rep(c, 0, 25) right[c][i] = right[c][i + 1];",
			"            right[S[i + 1]][i] = i + 1;",
			"        }",
			"        rep(c, 0, 25) {",
			"            left[c].resize(N);",
			"            left[c][0] = -1;",
			"        }",
			"        rep(i, 1, N - 1) {",
			"            rep(c, 0, 25) left[c][i] = left[c][i - 1];",
			"            left[S[i - 1]][i] = i - 1;",
			"        }",
			"    }",
			"    inline ll goright(ll cu, ll c) {",
			"        if (cu == INFI) return INFI;",
			"        if (cu < 0) {",
			"            if (S[0] == c) return 0;",
			"            cu = 0;",
			"        }",
			"        return right[c][cu];",
			"    }",
			"    inline ll goleft(ll cu, ll c) {",
			"        if (cu < 0) return cu;",
			"        return left[c][cu];",
			"    }",
			"};",
			"",
			"int main() {",
			"    $1",
			"    ll N;",
			"    string S;",
			"    cin >> N >> S;",
			"",
			"    fore(c, S) c -= '0';",
			"    findstr sm(S);",
			"",
			"    ll ans = 0;",
			"    rep(x0, 0, 9) rep(x1, 0, 9) rep(x2, 0, 9) {",
			"        ll cu = -1;",
			"        cu = sm.goright(cu, x0);",
			"        cu = sm.goright(cu, x1);",
			"        cu = sm.goright(cu, x2);",
			"        if (cu < INFI) ans++;",
			"    }",
			"    cout << ans << endl;",
			"}"
		]
	},
	"findpll": {
		"prefix": "findpll",
		"body": [
			"int main() {",
			"    $1",
			"    const ll max_this = 1000000;",
			"    ll n;",
			"    cin >> n;",
			"",
			"    vector<ll> x_n(n);",
			"    vector<ll> y_n(n);",
			"    set<pll> isin; ",
			"",
			"    for (ll i = 0; i < n; ++i) {",
			"        cin >> x_n[i] >> y_n[i];",
			"        isin.insert(make_pair(x_n[i], y_n[i])); // 座標をセットに挿入",
			"    }",
			"    // 座標が含まれるかをチェックするラムダ関数",
			"    auto check = [&](ll x, ll y) -> bool {",
			"        if (x < 0 || x > max_this || y < 0 || y > max_this) {",
			"            return false; // 範囲外",
			"        }",
			"        return isin.count(make_pair(x, y)) > 0; ",
			"    };",
			"",
			"    // 座標を入力してチェック",
			"    ll a, b;",
			"    cin >> a >> b;",
			"    if (check(a, b)) {",
			"        cout << \"Yes\" << endl;",
			"    } else {",
			"        cout << \"No\" << endl;",
			"    }",
			"",
			"    return 0;",
			"}"
		]
	},
	"tri": {
		"prefix": "tri",
		"body": [
			"ld my_tri(ld ok, ld ng, function<ld(ld)> f) {",
			" while (abs(ok - ng) > 1e-11) {",
			"   ld mid_l = (ok + ng * 2) / 3;",
			"   ld mid_r = (ok * 2 + ng) / 3;",
			"   if (f(mid_l) > f(mid_r)) {",
			"     ng = mid_l;",
			"   } else {",
			"     ok = mid_r;",
			"   }",
			" }",
			" return ok;",
			"}",
			"",
			"int main() {",
			"    $1",
			" ld p;",
			" cin >> p;",
			"",
			" auto f = [&](ld mid) {",
			"   return mid + p / pow(2, mid / 1.5);",
			" };",
			"",
			" ld idx = my_tri(INFL, 0, f);",
			" print(f(idx), 10);",
			" return 0;",
			"}",
		]
	},
	"dfs_one": {
		"prefix": "dfs_one",
		"body": [
			"// DFS を再帰的に実行する関数",
			"void dfs(int v, const vector<vector<int>> &graph, vector<bool> &seen) {",
			"    seen[v] = true;",
			"    for (int u : graph[v]) {",
			"        if (!seen[u])",
			"            dfs(u, graph, seen);",
			"    }",
			"}",
			"",
			"int main(){",
			"    ios::sync_with_stdio(false);",
			"    cin.tie(nullptr);",
			"",
			"    int n;",
			"    cin >> n;",
			"",
			"    // 隣接リスト形式でグラフを構築",
			"    vector<vector<int>> graph(n);",
			"    for (int i = 0; i < n; i++){",
			"        int u, k;",
			"        cin >> u >> k;",
			"        u--; // 0-indexed に変換",
			"        for (int j = 0; j < k; j++){",
			"            int v;",
			"            cin >> v;",
			"            v--; // 0-indexed に変換",
			"            graph[u].push_back(v);",
			"        }",
			"    }",
			"",
			"    vector<bool> seen(n, false);",
			"    int componentCount = 0; // 連結成分の個数",
			"",
			"    // 各頂点から DFS を実行（未訪問なら新たな連結成分の開始）",
			"    for (int i = 0; i < n; i++){",
			"        if (!seen[i]) {",
			"            componentCount++;",
			"            dfs(i, graph, seen);",
			"        }",
			"    }",
			"",
			"    // 連結成分の個数を出力",
			"    cout << componentCount << \"\\n\";",
			"",
			"    return 0;",
			"}"
		],
	},
	"dfs_grid": {
		"prefix": "dfs_grid",
		"body": [
			"// DFS 関数：グリッド上で連結するセルを探索する",
			"void dfs(const matrix &G, int h, int w, vector<vector<bool>> &visited) {",
			"    visited[h][w] = true;",
			"    for (int i = 0; i < 8; i++) {",
			"        int nh = h + dx[i];",
			"        int nw = w + dy[i];",
			"        if (nh >= 0 && nh < (int)G.size() && nw >= 0 && nw < (int)G[0].size()) {",
			"            if (!visited[nh][nw] && G[nh][nw] == 1)",
			"                dfs(G, nh, nw, visited);",
			"        }",
			"    }",
			"}",
			"",
			"int main(){",
			"    ios::sync_with_stdio(false);",
			"    cin.tie(nullptr);",
			"    ",
			"    ll W, H;",
			"    cin >> W >> H;",
			"    ",
			"    while(W != 0 || H != 0) {",
			"        matrix G(H, vector<ll>(W, 0));",
			"        for (int i = 0; i < H; i++) {",
			"            for (int j = 0; j < W; j++) {",
			"                cin >> G[i][j];",
			"            }",
			"        }",
			"        ",
			"        vector<vector<bool>> visited(H, vector<bool>(W, false));",
			"        int componentCount = 0;",
			"        ",
			"        for (int i = 0; i < H; i++) {",
			"            for (int j = 0; j < W; j++) {",
			"                if (!visited[i][j] && G[i][j] == 1) {",
			"                    componentCount++;",
			"                    dfs(G, i, j, visited);",
			"                }",
			"            }",
			"        }",
			"        ",
			"        cout << componentCount << \"\\n\";",
			"        cin >> W >> H;",
			"    }",
			"    ",
			"    return 0;",
			"}"
		]
	},
	"dfs_path": {
		"prefix": "dfs_path",
		"body": [
			"struct Edge {",
			"  int to;",
			"  ull w;",
			"};",
			"",
			"int N;",
			"ull ans = ULLONG_MAX; // 最小値を求めるので初期値は最大値",
			"vector<vector<Edge>> graph;",
			"",
			"void dfs(int v, ull cur, vector<bool> &used) {",
			"  if (v == N - 1) { // 目的地に到達",
			"    ans = min(ans, cur);",
			"    return;",
			"  }",
			"  for (auto &edge : graph[v]) {",
			"    if (!used[edge.to]) {",
			"      used[edge.to] = true;",
			"      dfs(edge.to, cur ^ edge.w, used);",
			"      used[edge.to] = false;",
			"    }",
			"  }",
			"}",
			"",
			"int main() {",
			"  ios::sync_with_stdio(false);",
			"  cin.tie(nullptr);",
			"",
			"  ll m;",
			"  in(N);",
			"  in(m);",
			"  graph.resize(N);",
			"  rep(i, 0, m) {",
			"    int u, v;",
			"    ull w;",
			"    in(u);",
			"    in(v);",
			"    in(w);",
			"    u--;",
			"    v--; // 0-indexedに変換",
			"    graph[u].push_back({v, w});",
			"    graph[v].push_back({u, w});",
			"  }",
			"",
			"  // DFSによる全単純パス探索",
			"  vector<bool> used(N, false);",
			"  used[0] = true;",
			"  dfs(0, 0, used);",
			"",
			"  cout << ans << \"\\n\";",
			"  return 0;",
			"}"
		],
	},
	"bfs_matrix": {
		"prefix": "bfs_matrix",
		"body": [
			"void bfs_matrix(const vector<string> &field, ll sx, ll sy, matrix &dist) {",
			"    ll height = field.size();",
			"    ll width = field[0].size();",
			"",
			"    // 探索中に各マスはどのマスから来たのかを表す配列",
			"    // (最短経路長を知るだけなら、これは不要)",
			"    vector<vector<ll>> prev_x(field.size(), vector<ll>(field[0].size(), -1));",
			"    vector<vector<ll>> prev_y(field.size(), vector<ll>(field[0].size(), -1));",
			"",
			"    queue<pair<ll, ll>> que;",
			"    dist = vector<vector<ll>>(height, vector<ll>(width, -1)); // 初期化",
			"    que.push(make_pair(sx, sy));                              // スタートを push",
			"    dist[sx][sy] = 0;                                         // スタートを 0 に",
			"",
			"    /* 幅優先探索を実施 */",
			"",
			"    while (!que.empty()) {",
			"        ll x = que.front().first;",
			"        ll y = que.front().second;",
			"        que.pop(); // キューから pop を忘れずに",
			"",
			"        // 隣接頂点を探索",
			"        rep(i, 0, 4) {",
			"            ll next_x = x + dx[i];",
			"            ll next_y = y + dy[i];",
			"",
			"            if (next_x < 0 || next_x >= height || next_y < 0 || next_y >= width)",
			"                continue;",
			"            if (field[next_x][next_y] == 'X')",
			"                continue;",
			"",
			"            // まだ見ていない頂点なら push",
			"            if (dist[next_x][next_y] == -1) {",
			"                que.push(make_pair(next_x, next_y));",
			"                dist[next_x][next_y] = dist[x][y] + 1; // (next_x, next_y) の距離も更新",
			"                prev_x[next_x][next_y] = x; // どの頂点から情報が伝播して来たか、縦方向の座標をメモ",
			"                prev_y[next_x][next_y] = y; // どの頂点から情報が伝播して来たか、横方向の座標をメモ",
			"            }",
			"        }",
			"    }",
			"}",
			"int main() {",
			"",
			"    /* 入力受け取り */",
			"",
			"    /* 縦と横の長さ */",
			"    ll h, w;",
			"    in(h,w);",
			"    ll sx, sy, gx, gy;",
			"    in(sx, sy, gx, gy);",
			"    sx--; sy--; gx--; gy--;",
			"    /* 盤面 */",
			"    vector<string> field(h);",
			"    rep(i,0,h)",
			"        cin >> field[i];",
			"",
			"    /* スタート地点とゴール地点 */",
			"    // ll sx, sy, gx, gy;",
			"    // rep(i,0,h){",
			"    //   rep(j,0,w) {",
			"    //     if (field[i][j] == 'S') {",
			"    //       sx = i;",
			"    //       sy = j;",
			"    //     }",
			"    //     if (field[i][j] == 'G') {",
			"    //       gx = i;",
			"    //       gy = j;",
			"    //     }",
			"    //   }",
			"    // }",
			"",
			"    /* 幅優先探索の初期設定 */",
			"",
			"    // 各セルの最短距離 (訪れていないところは -1 としておく)",
			"    vector<vector<ll>> dist(h, vector<ll>(w, -1));",
			"    bfs_matrix(field, sx, sy, dist);",
			"",
			"    /* 結果出力 */",
			"",
			"    // ll x = gx, y = gy;",
			"    // while (x != -1 && y != -1) {",
			"    //   field[x][y] = 'o'; // 通過したことを示す",
			"",
			"    //   // 前の頂点へ行く",
			"    //   ll px = prev_x[x][y];",
			"    //   ll py = prev_y[x][y];",
			"    //   x = px, y = py;",
			"    // }",
			"    //rep (i,0,h) {",
			"    //  rep(j,0,w) {",
			"    //     cout << std::setw(3) << field[i][j];",
			"    //   }",
			"    //   cout << endl;",
			"    // }",
			"",
			"    out(dist[gx][gy]);",
			"    return 0;",
			"}",
		]
	},
	"dp_matrix": {
		"prefix": "dp_matrix",
		"body": [
			"struct DP {",
			"    ll n, m;",
			"    matrix dp;",
			"",
			"    DP(ll _n, ll _m, ll init = 0) : n(_n), m(_m) {",
			"        dp.assign(n, onevec(m, init));",
			"    }",
			"",
			"    // 状態遷移の例（最小コストを求めるパターン）",
			"    void trmin(ll i, ll j, ll cost) {",
			"        if (i > 0) chmin(dp[i][j], dp[i - 1][j] + cost);",
			"        if (j > 0) chmin(dp[i][j], dp[i][j - 1] + cost);",
			"    }",
			"",
			"    // 状態遷移の例（最大コストを求めるパターン）",
			"    void trmax(ll i, ll j, ll cost) {",
			"        if (i > 0) chmax(dp[i][j], dp[i - 1][j] + cost);",
			"        if (j > 0) chmax(dp[i][j], dp[i][j - 1] + cost);",
			"    }",
			"",
			"    // 結果の取得",
			"    ll get_result() {",
			"        return dp[n - 1][m - 1];",
			"    }",
			"",
			"    // DP テーブルのデバッグ出力",
			"    void debug() {",
			"        rep(i, 0, n) {",
			"            rep(j, 0, m) cout << (dp[i][j] == INFL ? \"INF\" : to_string(dp[i][j])) << \" \";",
			"            cout << endl;",
			"        }",
			"    }",
			"};",
			"",
			"int main() {",
			"    ll n, m;",
			"    in(n,m);",
			"    DP dp(n, m, INFL);",
			"",
			"    // 初期化",
			"    dp.dp[0][0] = 0;",
			"",
			"    // 例: グリッド DP（右・下移動のみ）",
			"    rep(i, 0, n) rep(j, 0, m) {",
			"        ll cost;",
			"        in(cost);",
			"        dp.trmin(i, j, cost);",
			"    }",
			"",
			"    out(dp.get_result());",
			"    return 0;",
			"}"
		]
	},
	"inter_dp": {
		"prefix": "inter_dp",
		"body": [
			"ll n;",
			"onevec d;",
			"matrix dp;",
			"",
			"// 区間 [l, r] の最適解を求めるDP",
			"ll rec(ll l, ll r) {",
			"\tll &target = dp[l][r];",
			"\tif (target != -1) return target;",
			"\tif (l == r) return target = 0;",
			"",
			"\t// // 例: 区間全体を一括で処理できる場合",
			"\t// if (/* 条件（例えば data[l] と data[r] を使って処理できるか） */) {",
			"\t// \treturn target = /* 適切な値 */;",
			"\t// }",
			"",
			"\t// 例: 区間を左右から1つずつ減らして確認する場合",
			"\ttarget = max(rec(l + 1, r), rec(l, r - 1));",
			"",
			"\t// // 例: 区間を2つに分けて試す場合",
			"\t// for (ll i = l; i < r; ++i) {",
			"\t// \tchmax(target, rec(l, i) + rec(i + 1, r));",
			"\t// }",
			"",
			"\treturn target;",
			"}",
			"",
			"int main() {",
			"\tios::sync_with_stdio(false);",
			"\tcin.tie(nullptr);",
			"",
			"\tin(n);",
			"",
			"\td.resize(n);",
			"\trep(i, 0, n) in(d[i]);",
			"",
			"\tdp.assign(n+1, onevec(n+1, -1));",
			"",
			"\tout(rec(0, n));",
			"",
			"\treturn 0;",
			"}"
		],
	},
	"lis": {
		"prefix": "lis",
		"body": [
			"// 関数: lisLength",
			"// 説明: 与えられた整数のシーケンスから最長増加部分列 (LIS) の長さを計算する",
			"// 引数: seq = 整数のベクトル",
			"// 戻り値: LIS の長さ (整数)",
			"ll lislen(const onevec& seq) {",
			"    // 空のシーケンスの場合は 0 を返す",
			"    if (seq.empty()) return 0;",
			"",
			"    onevec lis;  // 現在のLISを格納するベクトル",
			"    lis.push_back(seq[0]);",
			"",
			"    // シーケンスの2番目の要素から処理を開始",
			"    rep(i,1,lsize(seq)){",
			"        // 現在の要素がlisの最後の要素より大きい場合、末尾に追加",
			"        if (seq[i] > lis.back()) {",
			"            lis.push_back(seq[i]);",
			"        } else {",
			"            // そうでない場合、lower_boundを用いてseq[i]が入るべき位置を探す",
			"            auto pos = lower_bound(lis.begin(), lis.end(), seq[i]);",
			"            *pos = seq[i];  // 該当位置の値を更新",
			"        }",
			"    }",
			"",
			"    // lisに格納された要素数がLISの長さになる",
			"    return lis.size();",
			"}"
		],
	},
	"bfs_weight": {
		"prefix": "bfs_weight",
		"body": [
			"void bfs_weight(const vector<vector<pll>> &G, ll start, vector<ll> &dist) {",
			"  ll n = G.size();",
			"  min_priority_queue<pll> que;",
			"",
			"  dist[start] = 0; // 初期ノード",
			"  que.push({0, start});",
			"",
			"  while (!que.empty()) {",
			"    ll v = que.top().second;",
			"    ll d = que.top().first;",
			"    que.pop();",
			"",
			"    if (dist[v] < d) continue;",
			"",
			"    for (pll nv : G[v]) {",
			"      ll new_v = nv.first;",
			"      ll new_d = d + nv.second;",
			"      if (dist[new_v] <= new_d)",
			"        continue; // 訪問済み",
			"      dist[new_v] = new_d;",
			"      que.push({new_d, new_v});",
			"    }",
			"  }",
			"}",
			"",
			"int main() {",
			"  ll N, M, r; // 頂点数と辺数とスタート地点",
			"  in(N, M, r);",
			"",
			"  vector<vector<pll>> G(N);",
			"  for (ll i = 0; i < M; ++i) { // 辺の入力",
			"    ll u, v, d;",
			"    in(u, v, d);",
			"    u--;",
			"    v--; // 0-index",
			"    G[u].push_back({v, d});",
			"  }",
			"",
			"  vector<ll> dist(N, INFL); // 距離配列",
			"  bfs_weight(G, r, dist); // 頂点0を始点としてBFS実行",
			"",
			"  for (ll v = 0; v < N; ++v) {",
			"    (dist[v] == INFL) ? out(\"INF\") : out(dist[v]);",
			"  }",
			"",
			"  return 0;",
			"}"
		],
	},
	"warshall_floyd": {
		"prefix": "warshall_floyd",
		"body": [
			"int main() {",
			"  ios::sync_with_stdio(false);",
			"  cin.tie(nullptr);",
			"  ll N, M;",
			"  in(N, M);",
			"  matrix dp(N, onevec(N, INFL));",
			"  rep(i, 0, N) { dp[i][i] = 0; }",
			"  rep(i, 0, M) {",
			"    ll s, t, d;",
			"    in(s, t, d);",
			"    dp[s][t] = d;",
			"  }",
			"  for (int k = 0; k < N; k++) {",
			"    for (int i = 0; i < N; i++) {",
			"      for (int j = 0; j < N; j++)",
			"        if (dp[i][k] != INFL && dp[k][j] != INFL) {",
			"          dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j]);",
			"        }",
			"    }",
			"  }",
			"  rep(i, 0, N) {",
			"    if (dp[i][i] < 0) {",
			"      out(\"NEGATIVE CYCLE\");",
			"      return 0;",
			"    }",
			"  }",
			"  rep(i, 0, N) {",
			"    rep(j, 0, N) {",
			"      if (dp[i][j] == INFL) {",
			"        cout << \"INF\";",
			"      } else {",
			"        cout << dp[i][j];",
			"      }",
			"      if (j != N - 1) {",
			"        cout << \" \";",
			"      }",
			"    }",
			"    cout << \"\\n\";",
			"  }",
			"  return 0;",
			"}"
		],
	},
	"kruskal": {
		"prefix": "kruskal",
		"body": [
			"/* UnionFind：素集合系管理の構造体(union by rank)",
			"    isSame(x, y): x と y が同じ集合にいるか。 計算量はならし O(α(n))",
			"    unite(x, y): x と y を同じ集合にする。計算量はならし O(α(n))",
			"*/",
			"struct UnionFind { // The range of node number is 0 to n-1",
			"  vector<ll> rank, parents;",
			"  UnionFind() {}",
			"  UnionFind(ll n) { // make n trees.",
			"    rank.resize(n, 0);",
			"    parents.resize(n, 0);",
			"    rep(i, 0, n) { makeTree(i); }",
			"  }",
			"  void makeTree(ll x) {",
			"    parents[x] = x; // the parent of x is x",
			"    rank[x] = 0;",
			"  }",
			"  bool isSame(ll x, ll y) { return findRoot(x) == findRoot(y); }",
			"  void unite(ll x, ll y) {",
			"    x = findRoot(x);",
			"    y = findRoot(y);",
			"    if (rank[x] > rank[y]) {",
			"      parents[y] = x;",
			"    } else {",
			"      parents[x] = y;",
			"      if (rank[x] == rank[y]) {",
			"        rank[y]++;",
			"      }",
			"    }",
			"  }",
			"  int findRoot(ll x) {",
			"    if (x != parents[x])",
			"      parents[x] = findRoot(parents[x]);",
			"    return parents[x];",
			"  }",
			"};",
			"",
			"// 辺の定義",
			"struct Edge {",
			"  long long u;",
			"  long long v;",
			"  long long cost;",
			"};",
			"bool comp_e(const Edge &e1, const Edge &e2) {",
			"  return e1.cost < e2.cost;",
			"} // 辺を直接比較するための関数",
			"",
			"/* Kruskal :クラスカル法で minimum spanning tree を求める構造体",
			"    入力: 辺のvector, 頂点数V",
			"    最小全域木の重みの総和: sum",
			"    計算量: O(|E|log|V|)",
			"*/",
			"struct Kruskal {",
			"  UnionFind uft;",
			"  ll sum;  // 最小全域木の重みの総和",
			"  ll size; // 木の数",
			"  vector<Edge> edges;",
			"  ll V;",
			"  ll K;",
			"  Kruskal(const vector<Edge> &edges_, ll V_, ll K_)",
			"      : edges(edges_), V(V_), K(K_), size(V_) {",
			"    init();",
			"  }",
			"  void init() {",
			"    sort(edges.begin(), edges.end(), comp_e); // 辺の重みでソート",
			"    uft = UnionFind(V);",
			"    sum = 0;",
			"    for (auto e : edges) {",
			"      if (size == K) {",
			"        break;",
			"      }",
			"      if (!uft.isSame(e.u, e.v)) { // 閉路にならなければ加える",
			"        uft.unite(e.u, e.v);",
			"        sum += e.cost;",
			"        size--;",
			"      }",
			"    }",
			"  }",
			"};",
			"",
			"// グラフが隣接リストで与えられる時はクラスカル法",
			"int main() {",
			"  ll N, M, K; // 頂点の数、辺の数,木の数",
			"  in(N, M, K);",
			"  vector<Edge> edges(M);",
			"  rep(i, 0, M) {",
			"    ll s, t, w; // start, goal, weight",
			"    in(s, t, w);",
			"    s--;",
			"    t--;",
			"    Edge e = {s, t, w};",
			"    edges[i] = e;",
			"  }",
			"  Kruskal krs(edges, N, K);",
			"  out(krs.sum);",
			"  return 0;",
			"}"
		],
	},
	"nCk": {
		"prefix": "nCk",
		"body": [
			"const int MOD = 1000000007;",
			"",
			"// W, H の最大値は 10^5 なので、最大 n = W+H-2 <= 2*10^5 とする",
			"const int MAX = 200005;",
			"",
			"ll fac[MAX], finv[MAX];",
			"",
			"// 階乗と逆元階乗の前計算",
			"void COMinit() {",
			"    fac[0] = 1;",
			"    for (int i = 1; i < MAX; i++) {",
			"        fac[i] = fac[i - 1] * i % MOD;",
			"    }",
			"    finv[MAX - 1] = modinv(fac[MAX - 1], MOD);",
			"    for (int i = MAX - 2; i >= 0; i--) {",
			"        finv[i] = finv[i + 1] * (i + 1) % MOD;",
			"    }",
			"}",
			"",
			"// 二項係数 C(n, k) の計算",
			"ll COM(int n, int k) {",
			"    if(n < k || n < 0 || k < 0)",
			"        return 0;",
			"    return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;",
			"}",
			"",
			"ll nHk(int n, int k) { return COM(n + k - 1, k); }",
			"",
			"int main() {",
			"    ios::sync_with_stdio(false);",
			"    cin.tie(nullptr);",
			"    ",
			"    int W, H;",
			"    cin >> W >> H;",
			"    ",
			"    COMinit();",
			"    // 経路数は C(W+H-2, W-1)",
			"    cout << COM(W + H - 2, W - 1) << \"\\n\";",
			"    ",
			"    return 0;",
			"}"
		],
	},
	"max_neighbor": {
		"prefix": "max_neighbor",
		"body": [
			"int main() {",
			"ios::sync_with_stdio(false);",
			"cin.tie(nullptr);",
			"int N;",
			"cin >> N;",
			"vector<long long> A(N);",
			"for (int i = 0; i < N; i++) {",
			"cin >> A[i];",
			"}",
			"sort(A.begin(), A.end());",
			"long long sum = 0;",
			"// 下半分と上半分の差の和を計算",
			"int k = N / 2; // N が偶数の場合は N/2，奇数の場合も floor(N/2)",
			"for (int i = 0; i < k; i++) {",
			"sum += A[N - 1 - i] - A[i];",
			"}",
			"long long ans = 0;",
			"if (N % 2 == 0) {",
			"// 偶数個の場合",
			"ans = 2 * sum - (A[k] - A[k - 1]);",
			"} else {",
			"// 奇数個の場合",
			"ans = 2 * sum - min(A[k] - A[k - 1], A[k + 1] - A[k]);",
			"}",
			"cout << ans << \"\\n\";",
			"return 0;",
			"}",
		]
	}
}